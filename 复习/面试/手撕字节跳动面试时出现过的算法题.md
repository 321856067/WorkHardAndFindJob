# 手撕字节跳动面试时出现过的算法题

[原博客链接](https://www.nowcoder.com/discuss/425581)

## 1.买股票的最佳时机

**leetcode 原题链接**：[买股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

**难度级别**：简单

**题目**：
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
注意：你不能在买入股票前卖出股票。

**示例1**：
>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

**示例2**:
>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

**思路**：
先将每日的股票价格变成每日的变化量，然后求出最大子序列之和。
```java
class Solution {
    public int maxProfit(int[] prices) {
    	if(prices.length==0)
            return 0;
		int[] values = new int[prices.length];
		values[0] = 0;
        for(int i=1;i<prices.length;i++) {
        	values[i] = prices[i]-prices[i-1];
        }
        return maxSubSum(values);
    }
	
	public int maxSubSum(int[] values) {
		int res = values[0];
		for(int i=1;i<values.length;i++) {
			values[i] += Math.max(values[i-1], 0);
			res = Math.max(res, values[i]);
		}
		return res;
	}
}
```



## 2.跳跃游戏

**leetcode 原题链接**：[跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

**难度级别**：中等

**题目**：
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。

**示例1**：
>输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。

**示例2**:
>输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。

**思路**：
如果数组中没有 0，那么肯定能走到最后，如果有 0，那就得判断所有 0 前面的几个元素能否达到 0 以后的位置，如果不能，那就无法走到。
```java
class Solution {
    public boolean canJump(int[] nums) {
        if(nums.length == 1)
			return true;
		outter:for(int i=0;i<nums.length;i++) {
			if(nums[i]!=0)
				continue;
			for(int j=i-1;j>=0;j--) {
				if(nums[j] + j > i || nums[j] + j == nums.length-1)
					continue outter;
			}
			return false;
		}
		return true;
    }
}
```
或者官方思路，看最远能到的地方：
```java
public class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int rightmost = 0;
        for (int i = 0; i < n; ++i) {
            if (i <= rightmost) {
                rightmost = Math.max(rightmost, i + nums[i]);
                if (rightmost >= n - 1) {
                    return true;
                }
            }
        }
        return false;
    }
}
```



## 3.场景题：发红包

**题目**：
让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。

**思路**：
假设一共有 N 元，一共有 K 个人，则可以每个人拿到的钱为 random(N - (K - 1) * 0.01)，然后更新N，直到最后一个人就直接 N。



## 4.合并排序的数组

**leetcode 原题链接**：[合并排序的数组](https://leetcode-cn.com/problems/sorted-merge-lcci/)

**难度级别**：简单

**题目**：
给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。
初始化 A 和 B 的元素数量分别为 m 和 n。

**示例**：
>输入:
A = [1,2,3,0,0,0], m = 3
B = [2,5,6],       n = 3
输出: [1,2,2,3,5,6]

**说明**：
* A.length == n + m

**思路**：
想到的方法有两种：
(1) 将 B 放进 A 的尾部后对整个数组进行排序
```java
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {
        for(int i=m;i<m+n;i++) {
			A[i] = B[i-m];
		}
		Arrays.sort(A);
    }
}
```

(2) 利用双指针法。我们知道如果从头开始，那么数组 A 的元素会被覆盖，那么我们可以从后面开始。
```java
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {
        int i = m-1, j = n-1;
		int index = m+n-1;
		while(i>=0 && j>=0) {
			if(A[i] > B[j]) {
				A[index] = A[i];
				i--;
			}else {
				A[index] = B[j];
				j--;
			}
			index --;
		}
		while(i>=0) {
			A[index] = A[i];
			index--;
			i--;
		}
		while(j>=0) {
			A[index] = B[j];
			index--;
			j--;
		}
    }
}
```



## 5.剪绳子

**leetcode 原题链接**：[剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

**难度级别**：中等

**题目**：
给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问`k[0]*k[1]*...*k[m-1]`可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。

**示例1**：
>输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

**示例2**：
>输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

**提示**：
* 2 <= n <= 58

**思路**：
方法1：动态规划
```java
class Solution{
	public int cuttingRope(int n) {

//		浪费一个空间，方便了逻辑
		if(n <= 3)
			return n-1;
		int[] dp = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		dp[2] = 1;
		dp[3] = 2;
		for(int i=4;i<=n;i++) {
			for(int j=0;j<i;j++) {
//				这边还要跟自己相比是因为每次剪的长度都要跟之前的最大值比一下。
				dp[i] = Math.max(dp[i], Math.max(dp[i-j] * j, (i-j) * j));
			}
		}
		return dp[n];
    }
}
```

方法2：贪心算法。思想是长度为 3 的越多越好，其次是 2， 最次是 1。
```java
	public int cuttingRope(int n) {
		if(n <= 3)
			return n-1;
		if(n%3 == 0) return (int) Math.pow(3, n/3);
		if(n%3 == 1) return (int) Math.pow(3, n/3-1) * 4;
		if(n%3 == 2) return (int) Math.pow(3, n/3 - 1) * 6;
		return 0;
	}
```



## 6.有序数组中不重复元素的个数

**题目**：
给定一个有序数组，请算出平方后的结果可能的个数。

**思路**：
方法1：平方后进行快排并遍历。
```java
	public int findElements(int[] nums) {
		for(int i=0;i<nums.length;i++) {
			nums[i] *= nums[i];
		}
		Arrays.sort(nums);
		int sum = 1;
		for(int i=1;i<nums.length;i++) {
			if(nums[i] != nums[i-1]) {
				sum ++;
			}
		}
		return sum;
	}
```

方法2：双指针，一个从前往后，一个从后往前。
```java
class Solution{
	public int findElements(int[] arr) {
		if(arr == null || arr.length == 0){
            return 0;
        }
        if(arr.length == 1){
            return 1;
        }
        for(int i = 0; i < arr.length; i++){//将所有负数转正
            arr[i] =  Math.abs(arr[i]);
        }
        int head = 0, tail = arr.length - 1;
        int lastBig = -1;//上一个数据
        int count = 0;//不一样的数的个数
        while(head <= tail){//注意这里是小于等于
           while(head < arr.length && arr[head] == lastBig){
               head++;
           }
           while(tail >= 0 && arr[tail] == lastBig){
               tail--;
           }
           if(head <= tail){
               count++;
               if(arr[head] > arr[tail]){
                   lastBig = arr[head];
                   head++;
               }else{
                   lastBig = arr[tail];
                   tail--;
               }
           }else{
               return count;
           }
        }
        return count;
	}
}
```



## 7.找出不重复的元素个数

**题目**：
一个数据先递增再递减，找出数组不重复的个数。不能使用额外空间，复杂度o(n) 

**思路**：
显然要先找到最大元素的位置，然后朝两边移动。
```java
	public int findElements(int[] nums) {
		int res = 0;
		// 找到最大的数
		int maxIndex = 0;
		for(int i=1;i<nums.length;i++) {
			if(nums[i] < nums[i-1]) {
				maxIndex = i-1;
				break;
			}
		}
		res ++;
		// 找到左右两指针开始的位置
		int left = maxIndex -1, right = maxIndex + 1;
		while(left - 1>=0 && nums[left] == nums[maxIndex]) left --;
		while(right + 1<nums.length && nums[right] == nums[maxIndex]) right ++;
		// 开始比较
		int temp = nums[maxIndex] + 1;
		while(left >=0 && right <nums.length) {
			if(nums[left] == nums[right]) {
				if(nums[left] != temp) {
					res ++;
					temp = nums[left];
				}
				left -- ;
				right ++;
			}else if(nums[left] < nums[right]){
				res ++;
				right ++;
			}else {
				res ++;
				left --;
			}
		}
		return res;
	}
```



## 8.找范围

**题目**：
高考成绩2000万数据，分数0-750，如何快速知道你的排名，如何知道任一分数排名？

**思路**：
利用桶排序。
将分数分成 0 - 150， 151 - 300， 301 - 450， 451 - 600， 601 - 750 共五个区间（每个区间内还可以再分），将 2000 万分数据按照成绩分到对应的成绩区间中。这样就可以快速查到对应分数的排名了。



## 9.测时间

**题目**：
两根香，一根烧完1小时，如何测量15分钟

**思路**：
先将一根香的一端点燃，另一根香的两端全部点燃。当第二根香全部烧完时，此时已经过了半个小时。再将第一根香的另一端也点燃，那么此时第一根香剩下部分烧完的时间就是 15 min。



## 10.链表相交

**leetcode 原题链接**：[面试题 02.07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

**难度级别**：简单

**题目**：
给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第 k 个节点与另一个链表的第 j 个节点是同一节点（引用完全相同），则这两个链表相交。

**示例1**：
>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

**示例2**：
>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

**示例3**：
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。

**注意**：
* 如果两个链表没有交点，返回 null 。
* 在返回结果后，两个链表仍须保持原有的结构。
* 可假定整个链表结构中没有循环。
* 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

**思路**：
这边为了满足 O(1) 的内存，因此不去使用 Set 来做，而是使用遍历来做。
我们先假设两条链表头分别为 A、B，他们相交的点为 C，他们的终点为 D（这边只能是 Y 型相交，即相交后两条链表合为了一条，如果是 X 型相交显然是做不了的）。那么让两个指针一起分别从 A、B 开始遍历，直到遍历到最后，然后遍历另一条链表。那么此时势必会出现这样一个情况，从 A 遍历的指针走完第一条链表长度为 AC + CD，从 B 遍历的指针走完第一条链表长度为 BC + CD，当他们都遍历第二条链表后，一定会到达这样一个节点，在这个节点两个指针走过的路长分别为 AC + CD + BC 和 BC + CD + AC，即这个点即为相交的 C 点。
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p = headA, q = headB;
        // 两个指针用来记录链表的尾部
        ListNode aTail = null, bTial = null;
        while(p != q) {
        	if(p == null) {
        		p = headB;
        	}else {
        		if(p.next == null) {
        			aTail = p;
        		}
        		p = p.next;
        	}
        	if(q == null) {
        		q = headA;
        	}else {
        		if(q.next == null) {
        			bTial = q;
        		}
        		q = q.next;
        	}
        	// 当两个链表都已经遍历结束了，查看尾部是否相同，如果相同则证明有交点，不相同则证明无交点
        	if(aTail != null && bTial != null && aTail!=bTial) {
        		return null;
        	}
        }
        return q;
    }
}
```



## 11.求平方根

**题目**：
（这道题目跟 leetcode 上的不一样，leetcode 上只要求整数，这个还有精度）
写一个函数，求平方根，函数参数为目标数字和精度，测试案例 fn(4.1,0.001) fn(501.1,0.001) fn(0.045,0.001)  

**思路**：
分成两部分，求整数部分和小数部分，整数部分使用二分查找，也可以用二分。
```

```


















