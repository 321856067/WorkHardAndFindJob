# 手撕字节跳动面试时出现过的算法题

[原博客链接](https://www.nowcoder.com/discuss/425581)

## 1.买股票的最佳时机

**leetcode 原题链接**：[买股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

**难度级别**：简单

**题目**：
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
注意：你不能在买入股票前卖出股票。

**示例1**：
>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

**示例2**:
>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

**思路**：
先将每日的股票价格变成每日的变化量，然后求出最大子序列之和。
```java
class Solution {
    public int maxProfit(int[] prices) {
    	if(prices.length==0)
            return 0;
		int[] values = new int[prices.length];
		values[0] = 0;
        for(int i=1;i<prices.length;i++) {
        	values[i] = prices[i]-prices[i-1];
        }
        return maxSubSum(values);
    }
	
	public int maxSubSum(int[] values) {
		int res = values[0];
		for(int i=1;i<values.length;i++) {
			values[i] += Math.max(values[i-1], 0);
			res = Math.max(res, values[i]);
		}
		return res;
	}
}
```



## 2.跳跃游戏

**leetcode 原题链接**：[跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

**难度级别**：中等

**题目**：
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。

**示例1**：
>输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。

**示例2**:
>输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。

**思路**：
如果数组中没有 0，那么肯定能走到最后，如果有 0，那就得判断所有 0 前面的几个元素能否达到 0 以后的位置，如果不能，那就无法走到。
```java
class Solution {
    public boolean canJump(int[] nums) {
        if(nums.length == 1)
			return true;
		outter:for(int i=0;i<nums.length;i++) {
			if(nums[i]!=0)
				continue;
			for(int j=i-1;j>=0;j--) {
				if(nums[j] + j > i || nums[j] + j == nums.length-1)
					continue outter;
			}
			return false;
		}
		return true;
    }
}
```
或者官方思路，看最远能到的地方：
```java
public class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int rightmost = 0;
        for (int i = 0; i < n; ++i) {
            if (i <= rightmost) {
                rightmost = Math.max(rightmost, i + nums[i]);
                if (rightmost >= n - 1) {
                    return true;
                }
            }
        }
        return false;
    }
}
```



## 3.场景题：发红包

**题目**：
让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。

**思路**：
假设一共有 N 元，一共有 K 个人，则可以每个人拿到的钱为 random(N - (K - 1) * 0.01)，然后更新N，直到最后一个人就直接 N。



## 4.合并排序的数组

**leetcode 原题链接**：[合并排序的数组](https://leetcode-cn.com/problems/sorted-merge-lcci/)

**难度级别**：简单

**题目**：
给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。
初始化 A 和 B 的元素数量分别为 m 和 n。

**示例**：
>输入:
A = [1,2,3,0,0,0], m = 3
B = [2,5,6],       n = 3
输出: [1,2,2,3,5,6]

**说明**：
* A.length == n + m

**思路**：
想到的方法有两种：
(1) 将 B 放进 A 的尾部后对整个数组进行排序
```java
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {
        for(int i=m;i<m+n;i++) {
			A[i] = B[i-m];
		}
		Arrays.sort(A);
    }
}
```

(2) 利用双指针法。我们知道如果从头开始，那么数组 A 的元素会被覆盖，那么我们可以从后面开始。
```java
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {
        int i = m-1, j = n-1;
		int index = m+n-1;
		while(i>=0 && j>=0) {
			if(A[i] > B[j]) {
				A[index] = A[i];
				i--;
			}else {
				A[index] = B[j];
				j--;
			}
			index --;
		}
		while(i>=0) {
			A[index] = A[i];
			index--;
			i--;
		}
		while(j>=0) {
			A[index] = B[j];
			index--;
			j--;
		}
    }
}
```



## 5.剪绳子

**leetcode 原题链接**：[剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

**难度级别**：中等

**题目**：
给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问`k[0]*k[1]*...*k[m-1]`可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。

**示例1**：
>输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

**示例2**：
>输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

**提示**：
* 2 <= n <= 58

**思路**：
方法1：动态规划
```java
class Solution{
	public int cuttingRope(int n) {

//		浪费一个空间，方便了逻辑
		if(n <= 3)
			return n-1;
		int[] dp = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		dp[2] = 1;
		dp[3] = 2;
		for(int i=4;i<=n;i++) {
			for(int j=0;j<i;j++) {
//				这边还要跟自己相比是因为每次剪的长度都要跟之前的最大值比一下。
				dp[i] = Math.max(dp[i], Math.max(dp[i-j] * j, (i-j) * j));
			}
		}
		return dp[n];
    }
}
```

方法2：贪心算法。思想是长度为 3 的越多越好，其次是 2， 最次是 1。
```java
	public int cuttingRope(int n) {
		if(n <= 3)
			return n-1;
		if(n%3 == 0) return (int) Math.pow(3, n/3);
		if(n%3 == 1) return (int) Math.pow(3, n/3-1) * 4;
		if(n%3 == 2) return (int) Math.pow(3, n/3 - 1) * 6;
		return 0;
	}
```



## 6.有序数组中不重复元素的个数

**题目**：
给定一个有序数组，请算出平方后的结果可能的个数。

**思路**：
方法1：平方后进行快排并遍历。
```java
	public int findElements(int[] nums) {
		for(int i=0;i<nums.length;i++) {
			nums[i] *= nums[i];
		}
		Arrays.sort(nums);
		int sum = 1;
		for(int i=1;i<nums.length;i++) {
			if(nums[i] != nums[i-1]) {
				sum ++;
			}
		}
		return sum;
	}
```

方法2：双指针，一个从前往后，一个从后往前。
```java
class Solution{
	public int findElements(int[] arr) {
		if(arr == null || arr.length == 0){
            return 0;
        }
        if(arr.length == 1){
            return 1;
        }
        for(int i = 0; i < arr.length; i++){//将所有负数转正
            arr[i] =  Math.abs(arr[i]);
        }
        int head = 0, tail = arr.length - 1;
        int lastBig = -1;//上一个数据
        int count = 0;//不一样的数的个数
        while(head <= tail){//注意这里是小于等于
           while(head < arr.length && arr[head] == lastBig){
               head++;
           }
           while(tail >= 0 && arr[tail] == lastBig){
               tail--;
           }
           if(head <= tail){
               count++;
               if(arr[head] > arr[tail]){
                   lastBig = arr[head];
                   head++;
               }else{
                   lastBig = arr[tail];
                   tail--;
               }
           }else{
               return count;
           }
        }
        return count;
	}
}
```



## 7.找出不重复的元素个数

**题目**：
一个数据先递增再递减，找出数组不重复的个数。不能使用额外空间，复杂度o(n) 

**思路**：
显然要先找到最大元素的位置，然后朝两边移动。
```java
	public int findElements(int[] nums) {
		int res = 0;
		// 找到最大的数
		int maxIndex = 0;
		for(int i=1;i<nums.length;i++) {
			if(nums[i] < nums[i-1]) {
				maxIndex = i-1;
				break;
			}
		}
		res ++;
		// 找到左右两指针开始的位置
		int left = maxIndex -1, right = maxIndex + 1;
		while(left - 1>=0 && nums[left] == nums[maxIndex]) left --;
		while(right + 1<nums.length && nums[right] == nums[maxIndex]) right ++;
		// 开始比较
		int temp = nums[maxIndex] + 1;
		while(left >=0 && right <nums.length) {
			if(nums[left] == nums[right]) {
				if(nums[left] != temp) {
					res ++;
					temp = nums[left];
				}
				left -- ;
				right ++;
			}else if(nums[left] < nums[right]){
				res ++;
				right ++;
			}else {
				res ++;
				left --;
			}
		}
		return res;
	}
```



## 8.找范围

**题目**：
高考成绩2000万数据，分数0-750，如何快速知道你的排名，如何知道任一分数排名？

**思路**：
利用桶排序。
将分数分成 0 - 150， 151 - 300， 301 - 450， 451 - 600， 601 - 750 共五个区间（每个区间内还可以再分），将 2000 万分数据按照成绩分到对应的成绩区间中。这样就可以快速查到对应分数的排名了。



## 9.测时间

**题目**：
两根香，一根烧完1小时，如何测量15分钟

**思路**：
先将一根香的一端点燃，另一根香的两端全部点燃。当第二根香全部烧完时，此时已经过了半个小时。再将第一根香的另一端也点燃，那么此时第一根香剩下部分烧完的时间就是 15 min。



## 10.链表相交

**leetcode 原题链接**：[面试题 02.07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

**难度级别**：简单

**题目**：
给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第 k 个节点与另一个链表的第 j 个节点是同一节点（引用完全相同），则这两个链表相交。

**示例1**：
>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

**示例2**：
>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

**示例3**：
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。

**注意**：
* 如果两个链表没有交点，返回 null 。
* 在返回结果后，两个链表仍须保持原有的结构。
* 可假定整个链表结构中没有循环。
* 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

**思路**：
这边为了满足 O(1) 的内存，因此不去使用 Set 来做，而是使用遍历来做。
我们先假设两条链表头分别为 A、B，他们相交的点为 C，他们的终点为 D（这边只能是 Y 型相交，即相交后两条链表合为了一条，如果是 X 型相交显然是做不了的）。那么让两个指针一起分别从 A、B 开始遍历，直到遍历到最后，然后遍历另一条链表。那么此时势必会出现这样一个情况，从 A 遍历的指针走完第一条链表长度为 AC + CD，从 B 遍历的指针走完第一条链表长度为 BC + CD，当他们都遍历第二条链表后，一定会到达这样一个节点，在这个节点两个指针走过的路长分别为 AC + CD + BC 和 BC + CD + AC，即这个点即为相交的 C 点。
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p = headA, q = headB;
        // 两个指针用来记录链表的尾部
        ListNode aTail = null, bTial = null;
        while(p != q) {
        	if(p == null) {
        		p = headB;
        	}else {
        		if(p.next == null) {
        			aTail = p;
        		}
        		p = p.next;
        	}
        	if(q == null) {
        		q = headA;
        	}else {
        		if(q.next == null) {
        			bTial = q;
        		}
        		q = q.next;
        	}
        	// 当两个链表都已经遍历结束了，查看尾部是否相同，如果相同则证明有交点，不相同则证明无交点
        	if(aTail != null && bTial != null && aTail!=bTial) {
        		return null;
        	}
        }
        return q;
    }
}
```



## 11.求平方根

**题目**：
（这道题目跟 leetcode 上的不一样，leetcode 上只要求整数，这个还有精度）
写一个函数，求平方根，函数参数为目标数字和精度，测试案例 fn(4.1,0.001) fn(501.1,0.001) fn(0.045,0.001)  

**思路**：
使用二分法
```java
class Solution {

	public float fn(float n, float e) {
		// 先求 e 的精度
		String d = String.valueOf(e);
		int lengh = d.length() - 2;
		float x = 0;
		if (n > 0 && e > 0) {
			float low = 0;
			float high = n;
			while (low < high) {
				// 二分，并控制精度
				float mid = Float.parseFloat(String.format("%." + lengh + "f", (low + high) / 2));
				if (mid * mid < n - e) {
					low = mid;
				} else if (mid * mid > n + e) {
					high = mid;
				} else {
					x = mid;
					break;
				}
			}
		}
		return x;

	}

}
```



## 12.场景题：互相关注表设计

**题目**：
场景题：需求：谁关注了我，我关注了谁，谁与我互相关注。表该如何设计，索引怎么建。查询语句怎么写

**思路**：
个人见解，表可以有：id、粉丝id、被追随者id 三个字段，索引可以建两个，分别是粉丝 id 和被追随者 id。




## 13.找 K 个最小值

**题目**：
10亿个数字，取最小的100个数

**思路**：
如果是几百或者几千的数字，还能用堆排给搞一下。但是 10 亿个恐怕是不行的。这边给出几种方法，是否可行还得大家自己判断，甚至可以互相叠加使用：
* (1) 单纯的堆排
* (2) 先通过 hash 去除重复元素，再通过堆排
* (3) 先桶排序，每个桶里再进行堆排序
* (4) 维持一个长度为 100 的数组，遍历 10 亿个数据，比较并加入到数组中




## 14.找出重复元素

**题目**：
1亿个正整数,范围是0-42亿。求出现次数是2的数字，空间复杂度 

**思路**：
这题和 leetcode 里面的题目不太一样，这道题没有说是否只有一个次数为 2 的数字，也没有说其他数字出现的次数，因此就把题目看成是有多个出现次数为 2 的数字，并且其他数字只会出现一次。
使用位图法来做。
```java
	// 这边是先遍历了一遍，找到数据中的最小值和最大值，从而减小位图法中数组的长度
	public void findDuplicated(int[] a) {
		int max = 0;
		int min = 0;
		for (int i = 0; i < a.length; i++) {
			max = Math.max(max, a[i]);
			min = Math.min(min, a[i]);
		}
		
		// 这边使用了 byte[]，而不是使用了 int[] 和 boolean[]，其实从原理上都可以的
		int length = max / 8 - min / 8 + 1;
		byte[] arry = new byte[length];
		for (int i = 0; i < a.length; i++) {
			int num = a[i];
			int index = num / 8 - min / 8;
			int k = (num - min) % 8;
			// 这边使用这样的判断是因为使用的是 byte[]，使用 int[] 或者 boolean[] 则使用另一种判断方法
			if((arry[index] & 1<<k) > 0) {
				System.out.println(num);
			}else {
				arry[index] |= (1<<k);
			}
		}
	}
```



## 15.二叉树层次遍历

**leetcode 原题链接**：[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

**难度级别**：中等

**题目**：
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**示例**：
二叉树：[3,9,20,null,null,15,7],
```
    3
   / \
  9  20
    /  \
   15   7

```
返回其层次遍历结果：
```
[
  [3],
  [9,20],
  [15,7]
]
```

**思路**：
层序遍历，一般都用队列。这算是 BFS 把，还有 DFS 就不写了。
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> list = new ArrayList<>();
		if(root == null)
			return list;
		Queue<TreeNode> queue = new LinkedList<>();
		queue.add(root);
		while(queue.size()!=0) {
			int size = queue.size();
			List<Integer> subList = new ArrayList<>();
			for(int i =0;i<size;i++) {
				TreeNode p = queue.poll();
				subList.add(p.val);
				if(p.left != null)
					queue.add(p.left);
				if(p.right!=null)
					queue.add(p.right);
			}
			list.add(subList);
		}
		return list;
    }
}
```



## 16.蛇形遍历二叉树

**leetcode 原题链接**：[103. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

**难度级别**：中等

**题目**：
给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

**示例**：
给定二叉树 [3,9,20,null,null,15,7],
```
    3
   / \
  9  20
    /  \
   15   7
```
返回锯齿形层次遍历如下：
```
[
  [3],
  [20,9],
  [15,7]
]
```

**思路**：
本来还想用 BFS，但是发现用 queue 加 stack 的方法好像有点问题，于是用了深度遍历
```java
	// BFS 想想看哪里有问题
	public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
		List<List<Integer>> list = new ArrayList<>();
		if(root == null)
			return list;
		int time = 1;
		Queue<TreeNode> queue = new LinkedList<>();
		Stack<TreeNode> stack = new Stack<>();
		queue.add(root);
		while(queue.size()!=0 || stack.size() !=0) {
			if(time == 1) {
				int size = queue.size();
				List<Integer> subList = new ArrayList<>();
				for(int i=0;i<size;i++) {
					TreeNode p = queue.poll();
					subList.add(p.val);
					if(p.left != null) {
						stack.push(p.left);
					}
					if(p.right != null) {
						stack.push(p.right);
					}
				}
				time = 2;
				list.add(subList);
			}else {
				int size = stack.size();
				List<Integer> subList = new ArrayList<>();
				for(int i=0;i<size;i++) {
					TreeNode p = stack.pop();
					subList.add(p.val);
					if(p.left != null) {
						queue.add(p.left);
					}
					if(p.right != null) {
						queue.add(p.right);
					}
				}
				time = 1;
				list.add(subList);
			}
		}
		return list;
    }
```
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
// 更新后的 BFS
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> list = new ArrayList<>(); 
		if(root == null)
			return list;
		int time = 1;
		LinkedList<TreeNode> queue = new LinkedList<>();
		Stack<TreeNode> stack = new Stack<>();
		stack.push(root);
		while(stack.size() !=0) {
			if(time % 2 == 1) {
				List<Integer> subList = new ArrayList<>();
				int size = stack.size();
				while(stack.size()!=0) {
					queue.add(stack.pop());
				}
				for(int i=0;i<size;i++) {
					TreeNode p = queue.poll();
					subList.add(p.val);
					if(p.left!=null)
						stack.push(p.left);
					if(p.right != null)
						stack.push(p.right);
				}
				list.add(subList);
				time ++;
			}else {
				List<Integer> subList = new ArrayList<>();
				int size = stack.size();
				while(stack.size()!=0) {
					queue.add(stack.pop());
				}
				for(int i=0;i<size;i++) {
					TreeNode p = queue.poll();
					subList.add(p.val);
					if(p.right!=null)
						stack.push(p.right);
					if(p.left != null)
						stack.push(p.left);
				}
				list.add(subList);
				time ++;
			}
		}
		return list;
    }
}
```

```java
	// DFS
	public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
	    if (root == null) {
	      return new ArrayList<List<Integer>>();
	    }
	    List<List<Integer>> results = new ArrayList<List<Integer>>();
	    DFS(root, 0, results);
	    return results;
	}
	public void DFS(TreeNode node, int level, List<List<Integer>> results) {
	    if (level >= results.size()) {
	      LinkedList<Integer> newLevel = new LinkedList<Integer>();
	      newLevel.add(node.val);
	      results.add(newLevel);
	    } else {
	      if (level % 2 == 0)
	        results.get(level).add(node.val);
	      else
	        results.get(level).add(0, node.val);
	    }

	    if (node.left != null) DFS(node.left, level + 1, results);
	    if (node.right != null) DFS(node.right, level + 1, results);
	}
```



## 17.链表求和

**leetcode 原题链接**：[面试题 02.05. 链表求和](https://leetcode-cn.com/problems/sum-lists-lcci/)

**难度级别**：中等

**题目**：
给定两个用链表表示的整数，每个节点包含一个数位。
这些数位是反向存放的，也就是个位排在链表首部。
编写函数对这两个整数求和，并用链表形式返回结果。

**示例**：
>输入：(7 -> 1 -> 6) + (5 -> 9 -> 2)，即617 + 295
输出：2 -> 1 -> 9，即912

**进阶**：
进阶：假设这些数位是正向存放的，请再做一遍。

**示例**：
>输入：(6 -> 1 -> 7) + (2 -> 9 -> 5)，即617 + 295
输出：9 -> 1 -> 2，即912

**思路**：
遍历，并用一个标志位来表示进位即可。
```java
	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
		int flag = 0;
		ListNode p = new ListNode(0);
		ListNode t = p;
		while(l1!=null && l2!=null) {
			p.next = new ListNode((l1.val + l2.val + flag) %10);
			p = p.next;
			flag = (l1.val + l2.val + flag) /10;
			l1 = l1.next;
			l2 = l2.next;
		}
		while(l1 != null) {
			p.next = new ListNode((l1.val + flag) %10);
			p = p.next;
			flag = (l1.val + flag) /10;
			l1 = l1.next;
		}
		while(l2!=null) {
			p.next = new ListNode((l2.val + flag) %10);
			p = p.next;
			flag = (l2.val + flag) /10;
			l2 = l2.next;
		}
		if(flag == 1) {
			p.next = new ListNode(1);
		}
		return t.next;
    }
```
进阶就比较简单了，先原地反转两个链表，再执行上面的函数即可。
```java
	public ListNode reverseList(ListNode l1) {
		ListNode pre = null;
		ListNode next = null;
		while(l1 != null) {
			next = l1.next;
			l1.next = pre;
			pre = l1;
			l1 = next;
		}
		return pre;
	}

	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
		// 链表原地反转
		l1 = reverseList(l1);
		l2 = reverseList(l2);
		// 链表求和
		int flag = 0;
		ListNode p = new ListNode(0);
		ListNode t = p;
		while(l1!=null && l2!=null) {
			p.next = new ListNode((l1.val + l2.val + flag) %10);
			p = p.next;
			flag = (l1.val + l2.val + flag) /10;
			l1 = l1.next;
			l2 = l2.next;
		}
		while(l1 != null) {
			p.next = new ListNode((l1.val + flag) %10);
			p = p.next;
			flag = (l1.val + flag) /10;
			l1 = l1.next;
		}
		while(l2!=null) {
			p.next = new ListNode((l2.val + flag) %10);
			p = p.next;
			flag = (l2.val + flag) /10;
			l2 = l2.next;
		}
		if(flag == 1) {
			p.next = new ListNode(1);
		}
		return t.next;
    }
```



## 18.生成随机数

**题目**:
给定一个 0-4 随机数生成器 如何生成 0-6 随机数 

**思路**：
乍一看，我想法是 0-4 生成器的结果除以 4 再乘 6 不就好了。。。但其实没有这么简单，了解了真相的我眼泪掉下来

![随机数生成器](https://uploader.shimo.im/f/hRJICK49m4qHyhzV.png!thumbnail)




## 19.二叉树的最近公共祖先

**leetcode 原题链接**：[剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

**难度级别**：中等

**题目**：
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

```
		3
	  /   \
	 5     1
    /  \  /  \
   6   2  0   8
      / \
     7   4
```
**示例1**:
>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。

**示例2**：
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。

**说明**:
* 所有节点的值都是唯一的。
* p、q 为不同节点且均存在于给定的二叉树中。

**思路**
基本思路，DFS
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q)
			return root;
		TreeNode left = lowestCommonAncestor(root.left,p,q);
		TreeNode right = lowestCommonAncestor(root.right,p,q); 
		if(left == null)
			return right;
		if(right == null)
			return left;
		return root;
    }
}
```



## 20.二叉树中的最大路径和

**leetcode 原题链接**：[124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

**难度级别**：困难

**题目**：
给定一个非空二叉树，返回其最大路径和。
本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。

**示例1**：
```
输入: [1,2,3]

       1
      / \
     2   3

输出: 6
```

**示例2**：
```
输入: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出: 42
```

**思路**：
这道题其实不难，理解了递归很容易做出来，关键是理解题目的意思。题目的意思要求的一条**路径**的最大和，而路径是不能有岔路的。比如说：如果将上面的节点 9 替换成 11，如果是要连通节点的最大值，很明显是将所有节点都走一遍，那就是 43，但是如果是要路径，那么在节点 20 的时候，只能走 -10 -> 20 -> 15 或者 -10 -> 20 -> 7 或者 15 -> 20 -> 7 三条中的一条，而不能是 -10 -> 20 -> 15 -> 20(已走过) -> 7这样子。了解了这点以后，我们来写递归函数。
```java
class Solution{

	public int max = Integer.MIN_VALUE;

	public int maxPathSum(TreeNode root){
		maxGain(root);
		return max;
	}

	public int maxGain(TreeNode root){
		if(root == null) return 0;
		int left = Math.max(maxGain(root.left), 0);
		int right = Math.max(maxGain(root.right), 0);
		int value = root.val + left + right;
		max = Math.max(max, value);
		return root.val + Math.max(left, right);
	}
}
```



## 21.快速排序

手写快排。
快排其实是分治思想的一种，通过找一个基准点，使得该基准点左边的数字都小于等于该基准，基准点右边的数字都大于等于该基准，然后将左右两部分再进行排序，使得总体有序。实现方法通常使用头尾指针。

```java
	public void quickSort(int[] nums) {
		quickSort(nums, 0, nums.length - 1);
	}

	public void quickSort(int[] arr, int low, int high) {
		int i, j, temp, t;
		if (low > high)
			return;
		i = low;
		j = high;
		
		temp = arr[low];

		while (i < j) {
			while (temp <= arr[j] && i < j) {
				j--;
			}
			while (temp >= arr[i] && i < j) {
				i++;
			}
			if (i < j) {
				t = arr[j];
				arr[j] = arr[i];
				arr[i] = t;
			}
		}

		arr[low] = arr[i];
		arr[i] = temp;

		quickSort(arr, low, j - 1);
		quickSort(arr, j + 1, high);
	}
```



## 22.二叉树的前序遍历非递归

**leetcode 原题链接**：[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

**难度级别**：中等

**题目**：

给定一个二叉树，返回它的 前序 遍历。

**示例**：
```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]
```

**进阶**：
递归算法很简单，你可以通过迭代算法完成吗？

**思路**：

递归实现
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<Integer> list = new ArrayList<>();

    public List<Integer> preorderTraversal(TreeNode root) {
		preorderTraversal1(root);
		return list;
    }
	
	public void preorderTraversal1(TreeNode root) {
		if(root==null) {
			return;
		}
        list.add(root.val);
		preorderTraversal(root.left);
		preorderTraversal(root.right);
	}
}
```

非递归（迭代）实现
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
		List<Integer> list = new ArrayList<>();
		Stack<TreeNode> stack = new Stack<>();
		if(root!=null)
			stack.push(root);
		while(stack.size()!=0) {
			TreeNode p = stack.pop();
			list.add(p.val);
			if(p.right!=null)
				stack.push(p.right);
			if(p.left!=null)
				stack.push(p.left);
		}
		return list;
    }
}
```



## 145.二叉树的后序遍历

**leetcode 原题链接**：[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

**难度级别**：困难

**题目**：

给定一个二叉树，返回它的 后序 遍历。

**示例**：
```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
```

**进阶**：

递归算法很简单，你可以通过迭代算法完成吗？

**思路**：

递归方法
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<Integer> list = new ArrayList<>();
	
	public List<Integer> postorderTraversal(TreeNode root) {
		if(root != null) {
			postorderTraversal1(root);
		}
		return list;
    }
	
	public void postorderTraversal1(TreeNode root) {
		if(root.left != null)
			postorderTraversal(root.left);
		if(root.right != null)
			postorderTraversal(root.right);
		list.add(root.val);
    }
}
```

非递归（迭代）方法
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
	
	public List<Integer> postorderTraversal(TreeNode root) {
		LinkedList<Integer> list  = new LinkedList<>();
		Stack<TreeNode> stack = new Stack<>();
		if(root != null)
			stack.push(root);
		while(!stack.isEmpty()) {
			TreeNode p = stack.pop();
			list.addFirst(p.val);
			if(p.left != null)
				stack.add(p.left);
			if(p.right != null)
				stack.add(p.right);
		}
		return list;
    }
}
```



## 24.最长连续递增数列

**leetcode 原题链接**：[128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

**难度级别**：困难

**题目**：

给定一个未排序的整数数组，找出最长连续序列的长度。
要求算法的时间复杂度为 O(n)。

**示例**：
>输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。

**思路**：
先遍历数组，将数字都存入到 HashSet 中便于在常量时间内找到值是否存在。然后再次遍历数组，当 set 中不存在 num-1 的时候，表示这是起点，然后寻找 num + 1， num + 2 ... num + k 是否存在，更新结果即可。
```java
class Solution {
    public int longestConsecutive(int[] nums) {
        int res = 0;
		HashSet<Integer> set = new HashSet<>();
		for(int num : nums) {
			set.add(num);
		}
		for(int num : nums) {
			if(!set.contains(num-1)) {
				int curLen = 1;
				while(set.contains(num + curLen)) {
					curLen ++;
				}
				res = Math.max(res, curLen);
			}
		}
		return res;
    }
}
```



## 25.（智力题）海盗分金币

**题目**：

有5个海盗，获得了100枚金币，于是他们要商量一个方法来分配金币。商议方式如下：
* (1) 由5个海盗轮流提出分配方案。
* (2) 如果超过半数海盗（包括提出者）同意该方案，则按照该方案分配。
* (3) 如果同意该方案的人数（包括提出者）小于等于半数，则提出者要被扔到海里喂鱼，剩下的海盗继续商议分配。
* (4) 海盗们都是绝对理性的，以自己尽可能多获得金币为目的。但是在收益相等的情况下，会倾向把提出者扔到海里。

问：第一个海盗应该提出怎样的分配方案，才能保证自己既不被扔到海里，又能使自己利益最大化？

这道题可以看这个[链接](https://mp.weixin.qq.com/s/GR7k-kKhw-U8AnnpQLzGGA)，挺有意思的。




## 26.接雨水

**leetcode 原题链接**：[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

**难度级别**：困难

**题目**：

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![接雨水](https://uploader.shimo.im/f/1susWMEI5AUVmY7j.png!thumbnail)

上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

**示例**：

>输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6

**思路**：

方法1：
一个简单的思路就是从位置 i 出发往左右两边遍历，然后找比位置 i 高的值 leftMax 和 rightMax，那么位置 i 的蓄水为 Math.min(leftMax, rightMax) - i。
```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        
        for(int i=0;i<height.length;i++) {
        	int now = height[i];
        	int leftMax = now;
        	int rightMax = now;
        	for(int left = i;left>=0;left--) {
        		leftMax = Math.max(leftMax, height[left]);
        	}
        	for(int right = i;right<height.length;right++) {
        		rightMax = Math.max(rightMax,  height[right]);
        	}
        	ans += (Math.min(rightMax, leftMax) - now);
        }
        
        return ans;
    }
}
```

方法2：
其实是对方法 1 的优化，将找最大值的过程使用数组记录下来，那么左边的最大值 lefeMax[i] = Math.max(lefMax[i-1], hegiht[i])，右边的最大值 rightMax[i] = Math.max(rightMax[i+1], height[i])。
```java
class Solution {
    public int trap(int[] height) {
        if(height.length==0)
			return 0;
        int ans = 0;
        int lenght = height.length;
        int[] leftMax = new int[lenght], rightMax = new int[lenght];
        leftMax[0] = height[0];
        rightMax[lenght-1] = height[lenght-1];
        for(int i=1;i<lenght;i++) {
        	leftMax[i] = Math.max(leftMax[i-1], height[i]);
        }
        for(int i=lenght-2;i>=0;i--) {
        	rightMax[i] = Math.max(rightMax[i+1], height[i]);
        }
        for(int i=0;i<lenght;i++) {
        	int now = height[i];
        	ans += (Math.min(leftMax[i], rightMax[i])-now); 
        }
        return ans;
    }
}
```

方法3：
使用辅助栈，如果当前 height[i] 的值小于等于栈顶元素，则入栈当前索引，否则我们可以知道当前栈顶元素被当前 height[i] 和栈顶的前一个元素所包围，更新 ans，并把当前索引入栈。
```java
class Solution {
    public int trap(int[] height) {
        if(height.length==0)
			return 0;
        int ans = 0;
        int lenght = height.length;
        Stack<Integer> stack = new Stack<>();
        stack.push(0);
        for(int i=1;i<lenght;i++) {
        	while(stack.size() > 0 && height[stack.peek()] < height[i]) {
        		int stackTop = stack.pop();
        		if(stack.isEmpty())
        			break;
        		int before = stack.peek();
        		int distance = i - before -1;
        		ans += (Math.min(height[i],height[before]) - height[stackTop]) * distance;
        	}
        	stack.push(i);
        }
        return ans;
    }
}
```

方法4：
双指针(有空再弄)



## 27. ip 判断

**题目**：

有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中

**思路**：

这个没有找到原题，那么我们就不写代码直接写思路了。

方案1：布隆过滤器。
布隆过滤器就是对多个 ip 通过多次 hash，将制定位置的标志设置为 1。在判断给定 ip 是否存在时，直接使用 ip 进行多次 hash，如果多次 hash 的索引所在值都为 1，那么存在。因此，布隆过滤器常用作垃圾短信、垃圾邮件的过滤机制（ps：布隆过滤器具有拒真、纳伪的特性）

方案2：一致性 hash 加上多个表
使用一致性 hash，将 ip 放到对应地址的表中。查找时进行一次 hash，找到所在的表，再在表中进行查找。



## 28. 二叉树的路径和

（找了一圈没找到原题。。。）

**题目**：

给定一棵二叉树，求根节点到叶子节点的最小路径和。

**思路**：

显然用递归，这边要注意，一定要到叶子节点，如果该节点存在一个子节点，显然是不行的。如
```
		1
	   /
	  2
	 / \
	3   4
```
上面的二叉树的结果应该是 6 而不是 1
```java
class Solution{
	public int minSum(TreeNode root) {
		if(root == null)
			return 0;
		if(root.left != null && root.right != null)
			return root.val + Math.min(minSum(root.left), minSum(root.right));
		else {
			if(root.left == null)
				return root.val + minSum(root.right);
			else {
				return root.val + minSum(root.left);
			}
		}
	}
}
```



## 29. 反转链表 + 每 k 个反转链表

这题其实有两题，我们分开来做，不过第二题显然要用到第一题的知识。

**leetcode 原题链接**：[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

**难度级别**：简单

**题目**：

反转一个单链表。

**示例**：

>输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL

**进阶**：

你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

**思路**：

首先是递归
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
		if(head == null || head.next == null)
			return head;
		ListNode cur = reverseList(head.next);
		head.next.next = head;
		head.next = null;
		return cur;
    }
}
```
然后是迭代：
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
		ListNode pre = null, cur = head, next = null;
		while(cur!=null) {
			next = cur.next;
			cur.next = pre;
			pre = cur;
			cur = next;
		}
		return pre;
    }
}
```

**leetcode 原题链接**：[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

**难度级别**：困难

**题目**：

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

**示例**：

给你这个链表：1->2->3->4->5
当 k = 2 时，应当返回: 2->1->4->3->5
当 k = 3 时，应当返回: 3->2->1->4->5

**说明**：

* 你的算法只能使用常数的额外空间。
* 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**思路**：

解法如下：
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
		// 建立一个哨兵节点用来返回
		ListNode dummy = new ListNode(0);
		dummy.next = head;
		
		// 两个指针用来保存需要反转数组的前后节点，用来恢复链表
		ListNode pre = dummy;
		ListNode next = dummy;
		
		// 需要一个 head 和 tail 用来保存被反转链表的头和尾
		ListNode tail = head;
		
		while(next!=null) {
			tail = head;
			// 找到尾节点
			for(int i=1;i<k && tail!=null;i++)
				tail = tail.next;
			
			// 如果不满足 k 个了，那么此时 tail 为 null，直接反转并跳出循环
			if(tail== null) {
				break;
			}
			
			//将尾结点的 next 保存并设为 null
			next = tail.next;
			tail.next = null;
			
			// 反转节点
			pre.next = reverse(head);
			
			// 重新赋值
			head.next = next;
			pre = head;
			head = head.next;
		}
		return dummy.next;
    }
	
	// 反转链表的迭代做法
	public ListNode reverse(ListNode head) {
		ListNode pre = null;
		ListNode cur = head;
		while(cur != null) {
			ListNode next = cur.next;
			cur.next = pre;
			pre = cur;
			cur = next;
		}
		return pre;
	}
}
```



## 30. 场景题：求中位数

**题目**：

2g内存，要求一个10g文件的中位数

**思路**：

其实就是外村排序。。。
首先将 10g 的文件分成 10 * 1g，然后读入两个 g 的内存，排序后输出，然后不断进行这样的操作。




## 31. 螺旋矩阵

**leetcode 原题链接**：[59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

**难度级别**：中等

**题目**：

给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

**示例**：
>输入: 3
输出:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]

**思路**：

设定几个边界即可
```java
class Solution {
    public int[][] generateMatrix(int n) {
		int l=0,r=n-1,u=0,d=n-1;
		int[][] res = new int[n][n];
		int num = 1, target = n * n;
		while(num <= target) {
			for(int i=l;i<=r;i++)
				res[u][i] = num++;
			u++;
			for(int i=u;i<=d;i++)
				res[i][r] = num++;
			r--;
			for(int i=r;i>=l;i--)
				res[d][i] = num++;
			d--;
			for(int i=d;i>=u;i--)
				res[i][l] = num++;
			l++;
		}
		return res;
    }
}
```



## 32. 数据结构 heap

**题目**：

讲一讲 heap 是什么？手写一个 heap

**思路**：

heap 即堆，根据性质可以分为大根堆和小根堆，存储形式是一棵完全二叉树，因此使用数组来保存。如果是大根堆，那么父节点大于等于子节点，根节点是最大的。如果是小根堆，那么父节点小于等于子节点，根节点是最小的。
手写堆就不手写了，直接附上源码
```java
import java.util.Arrays;
import java.util.Comparator;

import javax.security.auth.x500.X500Principal;

public class Heap<E> {

	Object[] queue;
	
	private int size;
	
	private static final int DEFAULT_SIZE = 16;
	
	private Comparator<? extends E> comparator;
	
	public Heap() {
		this(DEFAULT_SIZE, null);
	}
	
	public Heap(Comparator<? extends E> comparator) {
		this(DEFAULT_SIZE, comparator);
	}
	
	public Heap(int initialCapacity, Comparator<? extends E> comparator) {
		this.queue = new Object[initialCapacity];
	}
	
	public void grow(int size) {
//		当容量不足时，增加25%
		int oldCapacity = queue.length;
		int newCapacity = oldCapacity + (oldCapacity<=64?oldCapacity + 2:oldCapacity>>2);
		queue = Arrays.copyOf(queue, newCapacity);
	}
	
//	取出元素
	public E poll() {
		if (size == 0)
            return null;
		int s = --size;
        E result = (E) queue[0];
        E x = (E) queue[s];
        queue[s] = null;
        if (s != 0)
        	shiftDown(0, x);
        return result;
	}
	
//	插入元素
	public boolean add(E e) {
		if(e == null)
			throw new NullPointerException();
		int i = size;
		if(i >= queue.length) {
			grow(i + 1);
		}
		shiftUp(i, e);
		size ++;
		return true;
	}
	
	private void shiftDown(int k, E x) {
		Comparable<? super E> key = (Comparable<? super E>)x;
        int half = size >>> 1;
        while (k < half) {
            int child = (k << 1) + 1; 
            Object c = queue[child];
            int right = child + 1;
            if (right < size &&
                ((Comparable<? super E>) c).compareTo((E) queue[right]) > 0)
                c = queue[child = right];
            if (key.compareTo((E) c) <= 0)
                break;
            queue[k] = c;
            k = child;
        }
        queue[k] = key;
	}
	
	private void shiftUp(int k, E e) {
		Comparable<? super E> key = (Comparable<? super E>) e;
		while(k > 0) {
			int parent = (k -1) >>> 1; 
			Object t = queue[parent];
			if(key.compareTo((E) t) >= 0) {
				break;
			}
			queue[k] = t;
			k = parent;
		}
		queue[k] = key;
	}
}

```



## 33. 中文数字转阿拉伯数字

**问题**：

给定一个中文字符串，将其转换成对应的阿拉伯数字

**思路**：

其实就是按中文的个、十、百、千、万、亿来进行换算，想法简单但是变成比较麻烦



## 34. 重建二叉树

**leetcode 原题链接**：[剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

**难度级别**：中等

**题目**：

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如，给出：

>前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

返回如下的二叉树：
```
    3
   / \
  9  20
    /  \
   15   7
```

**限制**：

0 <= 节点个数 <= 5000

**思路**：

方法1：采用递归的方法重建。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
		return buildTree(preorder,0, preorder.length-1, inorder,0, inorder.length-1);
    }
	
	public TreeNode buildTree(int[] preorder,int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd) {
		if(preBegin > preEnd)
			return null;
		// 找到父节点，即 preorder 位于 preBegin 的值
		int val = preorder[preBegin];
		TreeNode t = new TreeNode(val);
		
		// 找到中序遍历中头结点的位置
		int inIndex = 0;
		for(int i=inBegin;i<=inEnd;i++) {
			if(inorder[i] == val)
				inIndex = i;
		}
		
		// 算出左、右子树的节点
		int left = inIndex - inBegin;
		int right = inEnd - inIndex;
		t.left = buildTree(preorder,preBegin + 1, preBegin + left, inorder, inBegin, inIndex-1);
		t.right = buildTree(preorder,preBegin + left + 1, preEnd, inorder, inIndex + 1, inEnd);
		
		return t;
	}
}
```

方法2：采用迭代的方式重建。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder == null || preorder.length == 0) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[0]);
        int length = preorder.length;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        stack.push(root);
        int inorderIndex = 0;
        for (int i = 1; i < length; i++) {
            int preorderVal = preorder[i];
            TreeNode node = stack.peek();
            if (node.val != inorder[inorderIndex]) {
                node.left = new TreeNode(preorderVal);
                stack.push(node.left);
            } else {
                while (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {
                    node = stack.pop();
                    inorderIndex++;
                }
                node.right = new TreeNode(preorderVal);
                stack.push(node.right);
            }
        }
        return root;
    }
}
```



## 35. 路径总和

**leetcode 原题链接**：[112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

**难度级别**：简单

**题目**：

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

**示例**: 

给定如下二叉树，以及目标和 sum = 22，

```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```

返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。

**思路**：

看来只能疯狂遍历了，也不知道是不是全是正整数。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null)
			return false;
		if(root.left == null && root.right == null) {
			if(sum - root.val == 0)
				return true;
		}
		return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
```



## 36. 路径总和-2

**leetcode 原题链接**：[113. 路径总和 2](https://leetcode-cn.com/problems/path-sum-ii/)

**难度级别**：中等

**题目**：

给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

说明: 叶子节点是指没有子节点的节点。

**示例**:
给定如下二叉树，以及目标和 sum = 22，

```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
```

返回

```
[
   [5,4,11,2],
   [5,8,4,5]
]
```

**思路**：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<List<Integer>> totalList = new ArrayList<>();
    
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
		if(root == null)
			return totalList;
		pathSum(root, sum, new ArrayList<>());
		return totalList;
		
    }
	
	public void pathSum(TreeNode root, int sum, List<Integer> list) {
		list.add(root.val);
		if(root.left == null && root.right == null && sum == root.val) {
			totalList.add(list);
			return;
		}
		if(root.left != null) {
			pathSum(root.left, sum - root.val, new ArrayList<>(list));
		}
		if(root.right != null) {
			pathSum(root.right, sum - root.val, new ArrayList<>(list));
		}
	}
}
```



## 37. 单例模式

**题目**：

手写单例模式

**思路**：

正好也有好久没写单例模式了，这边再重新全部写一下。一共其中方法，其中饿汉一种，饱汉四种，静态内部类一种，枚举一种。开搞。

```java
/**
* 首先是饿汉
* 饿汉的缺点就是如果长时间不用，那么从一开始就创建单例就会很浪费空间。但是饿汉是线程安全的，因为 static 属性只会被初始化一次
*/
class Singleton{

	private static Singleton instance = new Singleton();

	private Singleton(){}

	public static Singleton getInstance(){
		return Singleton.instance;
	}

}
```

```java
/**
* 四种饱汉
*/

// 饱汉0，优点是不会浪费空间，缺点是多线程下会重复创建，造成问题
class Singleton0{

	private static Singleton0 instance = null;

	private Singleton0(){}

	public static Singleton0 getInstance(){
		if(instance == null)
			instance = new Singleton0();
		return Singleton0.instance;
	}

}

// 饱汉1，优点是解决了线程安全问题，缺点是 synchronized 修饰整个方法，多线程抢锁浪费时间
class Singleton1{

	private static Singleton1 instance = null;

	private Singleton1(){}

	public synchronized static Singleton1 getInstance(){
		if(instance == null)
			instance = new Singleton1();
		return Singleton1.instance;
	}
}

// 饱汉2, double check,优点是将同步代码块细粒度话，缺点是如果一个线程刚分配完空间还没有进行初始化，可能就被另一个线程拿去用了
class Singleton2{

	private static Singleton2 instance = null;

	private Singleton2(){}

	public static Singleton2 getInstance(){
		if(instance == null){
			synchronized(Singleton2.class){
				if(instance == null)
					instance = new Singleton2();
			}
		}
		return instance;
	}
}

// 饱汉3，改进版 double check，优点是一定程度上解决了原版的问题，缺点是如果遇到反射还是不能根本上解决不暴露构造函数的问题
class Singleton3{

	private static volatile Singleton3 instance = null;

	private Singleton3(){}

	public static Singleton3 getInstance(){
		if(instance == null){
			synchronized(Singleton3.class){
				if(instance == null)
					instance = new Singleton3();
			}
		}
		return instance;
	}
}
```

```java
/**
* 静态内部类版
* 优点是：
* 1. 有饿汉的优点，static 关键字只会初始化一次
* 2. 静态内部类的优点在于只有在外部类调用 getInstance 时才会进行内部类的初始化。
* 3. 解决了反射的问题
*/
class Singleton{

	private Singleton(){}

	private static class InstanceHolder{
		private final static Singleton instance = new Singleton();
	}

	public static Singleton getInstance(){
		return InstanceHolder.instance;
	}

}
```

```java
/**
* 枚举类
* 优点是：
* 除了防止了反射，还能防止反序列化重新创建新的对象的问题，最提倡的写法
*/
class Singleton{

	private Singleton{}

	private static enum SingletonEnum{

		INSTANCE;

		private Singleton instance;

		private SingletonEnum(){
			singleton = new Singleton();
		}

		public Singleton getInstance(){
			return instance;
		}

	}

	public static Singleton getInstance(){
		return SingletonEnum.Instance.getInstance;
	}
}
```



## 38. 合并区间

**leetcode 原题链接**：[56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

**难度级别**：中等

**题目**：

给出一个区间的集合，请合并所有重叠的区间。

**示例1**：

>输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

**示例2**：

>输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。

**思路**：

我觉得吧，应该只能暴力解法了。首先将 intervals 按照左边起点进行从小到大的排序，然后判断右端点的位置，是否进行更新。

```java
class Solution {
    public int[][] merge(int[][] intervals) {
		List<int[]> res = new ArrayList<>();
		if (intervals.length == 0 || intervals == null)
			return res.toArray(new int[0][]);
		// 对起点终点进行排序
		Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
		int i = 0;
		while (i < intervals.length) {
			int left = intervals[i][0];
			int right = intervals[i][1];
			// 如果有重叠，循环判断哪个起点满足条件
			while (i < intervals.length - 1 && intervals[i + 1][0] <= right) {
				i++;
				right = Math.max(right, intervals[i][1]);
			}
			// 将现在的区间放进res里面
			res.add(new int[] { left, right });
			// 接着判断下一个区间
			i++;
		}
		return res.toArray(new int[0][]);
	}
}
```



## 39. 翻转字符串中的单词

**leetcode 原题链接**：[151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

**难度级别**：中等

**题目**：

给定一个字符串，逐个翻转字符串中的每个单词。

**示例1**：

>输入: "the sky is blue"
输出: "blue is sky the"

**示例2**：

>输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

**示例3**：

>输入: "a good   example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

**说明**：

* 无空格字符构成一个单词。
* 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
* 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

**进阶**：

请选用 C 语言的用户尝试使用 O(1) 额外空间复杂度的原地解法。

**思路**：

如果不考虑额外空间复杂度的话，比较简单
```java
class Solution {
    public String reverseWords(String s) {
        if(s.equals("")) return "";
		String[] strs = s.split(" ");
		StringBuilder sb = new StringBuilder();
		for(int i=strs.length-1;i>=0;i--) {
			if(strs[i].equals(""))
				continue;
			sb.append(strs[i]).append(" ");
		}
		return sb.toString().trim();
    }
}
```

如果考虑额外空间问题的话，Java 好像根本没法做，因为 Java 的 String 类型是不可变的。。。



## 40. 和为s的连续正整数序列

**leetcode 原题链接**：[剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

**难度级别**：简单

**题目**：

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

**示例1**：

>输入：target = 9
输出：[[2,3,4],[4,5]]

**示例2**：

>输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]

**限制**：

* 1 <= target <= 10^5

**思路**：

使用双指针，当 sum < target 时，sum +=j，j++；当 sum > target 时，sum -=i，i++；否则将 i 到 j 的数字添加到数组中
```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        int i = 1;
		int j = 1;
		int sum = 0;
		List<int[]> list = new ArrayList<>();
		while(i <= target/2){
			if(sum < target) {
				sum += j++;
			}else if(sum > target) {
				sum -= i++;
			}else {
				int[] k = new int[j-i];
				for(int t=i;t<j;t++) {
					k[t-i] = t;
				}
				list.add(k);
				sum -= i++;
			}
		}
		return list.toArray(new int[list.size()][]);
    }
}
```



## 41. 二分查找

**题目**：

介绍下二分查找，如果我想在链表中使用二分查找，怎么做比较好？

**思路**：

二分查找就是将查找有序的范围不断均分，将查找的值和中间值进行比较，从而缩小范围。

如果在链表中使用二分查找，那就得用跳表了。另外构建一个链表，链表有两个指针，一个是 next，指向下一个节点，一个是 main，指向原链表。保持每两个主链表节点有一个跳表节点。如 redis 的 zset。



## 42. 归并排序

**题目**：

介绍一下归并排序，时间复杂度多少？

**思路**：

归并排序其实就是首先将大的范围分成多个小部分，先保证整个小部分有序，然后再将各个小部分合并成较大的有序部分，直到整个部分都有序。时间复杂度为 O(nlogn)。



## 43. LRU 算法

**leetcode 原题链接**：[146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)

**难度级别**：中等

**题目**：

运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。

获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

**进阶**：

你是否可以在 O(1) 时间复杂度内完成这两种操作？

**示例**：

```
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得关键字 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得关键字 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```

**思路**：

使用一个双向队列来保存具体的键值对，并使用一个 map 来保存 key 和节点方便常数时间查找
```java
import java.util.HashMap;
import java.util.Map;

class LRUCache {
	
	Map<Integer, DListNode> map = new HashMap<>();
	int size;
	int capacity;
	DListNode head;
	DListNode tail;

    public LRUCache(int capacity) {
    	this.capacity = capacity;
    	this.size = 0;
    }
    
    public int get(int key) {
    	int res = -1;
    	// 如果 map 中存在，那么获得节点并将节点放到头部，并返回值
    	if(map.containsKey(key)) {
    		DListNode p = map.get(key);
    		moveToHead(p);
    		return p.val;
    	}
    	// 如果 map 中不存在，那么返回 -1
    	return res;
    }
    
    public void put(int key, int value) {
    	// 如果 map 中存在，获得节点并更新，并移到头部
    	if(map.containsKey(key)) {
    		DListNode p = map.get(key);
    		p.val = value;
    		moveToHead(p);
    	}
    	// 如果 map 中不存在
    	// 如果没有超出容量，新建节点并放在头部
    	// 如果超出容量，新建节点放在头部并删除尾部节点
    	else {
    		if(capacity > size) {
    			DListNode p = new DListNode(key, value);
    			moveToHead(p);
    			map.put(key, p);
    			size++;
    		}else {
    			DListNode p = new DListNode(key, value);
    			moveToHead(p);
    			map.put(key, p);
    			deleteTail();
    		}
    	}
    }
    
    private void moveToHead(DListNode p) {
    	if(head == p)
    		return;
    	if(p == tail) {
    		tail = p.pre;
    	}
    	else {
    		if(p.pre != null)
    			p.pre.next = p.next;
    		if(p.next != null)
    			p.next.pre = p.pre;
    	}
    	p.pre = null;
		p.next = head;
		if(head != null)
			head.pre = p;
		head = p;
		if(tail ==null)
			tail = head;
    }
    
    private void deleteTail() {
    	if(tail != null){
    		tail.pre.next = null;
    		map.remove(tail.key);
    		tail = tail.pre;
    	}
    }
    
    class DListNode{
    	int key;
    	int val;
    	DListNode pre;
    	DListNode next;
    	
    	public DListNode(int key, int val) {
			// TODO Auto-generated constructor stub
    		this.key = key;
    		this.val = val;
		}
    }
}
```



## 44. 数据库连接池

**题目**：

数据库连接池怎么设计？

**思路**：

需要考虑的事情有：
* 连接池的总数
* 空闲时的最大个数
* 饱和策略
* 归还用完的链接



## 45. 版本数字比较

**题目**：

版本数字比较，比如"1.10.0"版本比"1.8.1"版本新，不允许使用 split 等函数

**思路**：

双指针
```java
public static boolean versionCompare(String v1, String v2) {
		// 如果 v1 比 v2 新，返回 true，否则返回 false
		int length1 = v1.length();
		int length2 = v2.length();
		int l1 = 0, l2 = 0, r1 = 0, r2 = 0;
		while(r1 < length1 && r2 < length2) {
			while(r1 < length1 &&v1.charAt(r1) != '.') r1 ++;
			while(r2 < length2 &&v2.charAt(r2) != '.') r2 ++;
			int t1 = Integer.parseInt(v1.substring(l1, r1));
			int t2 = Integer.parseInt(v2.substring(l2, r2));
			if(t1 > t2)
				return true;
			else if(t1 < t2)
				return false;
			l1 = ++r1;
			l2 = ++r2;
		}
		return false;
    }
```



## 46. 文件拷贝

**题目**：

 某一个大文件被拆成了 N 个小文件，每个小文件编号从 0 至 N-1，相应大小分别记为 S(i)。给定磁盘空间为 C ，试实现一个函数从 N 个文件中连续选出若干个文件拷贝到磁盘中，使得磁盘剩余空间最小。

**思路**：

仔细一看，这不就是数组里面找最接近 target 的连续子数组嘛。使用双指针

```java
	public int[] findNearest(int[] s, int target) {
		int head = 0, tail = 0;
		int rH = 0, rT = 0;
		int res = s[0];
		int temp = 0;
		while(head<s.length && tail<s.length) {
			if(temp < target) {
				temp += s[tail];
				tail ++;
			}else if(temp > target){
				temp -= s[head];
				head++;
			}else {
				break;
			}
			if(Math.abs(res-target) >= Math.abs(temp - target)) {
				res = temp;
				rH = head;
				rT = tail;
			}
		}
		int[] ans = new int[rT - rH];
		for(int i=0;i<ans.length;i++) {
			ans[i] = s[rH+i];
		}
		return ans;
	}
```



## 47. 场景题：redis 高并发

**问题**：

redis 设置高并发抢单一的东西，如何避免高并发对一个键进行访问？

**思路**：

不太懂这个问题是想问什么？是想问分布式锁呢还是高并发解决流量问题



## 48. 最大栈

（leetcode 上这题是会员专享，因此我们找一题类似的“最小栈”，题目意思差不多，仅仅是把最大换成最小）

**leetcode 原题链接**：[716.最大栈](https://leetcode-cn.com/problems/max-stack/)

**难度级别**：简单

**题目**：

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最大元素的栈。

* push(x) —— 将元素 x 推入栈中。
* pop() —— 删除栈顶的元素。
* top() —— 获取栈顶元素。
* getMax() —— 检索栈中的最大元素。

**示例**：

>输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]
输出：
[null,null,null,null,-3,null,0,-2]
解释：
MaxStack maxStack = new MaxnStack();
maxStack.push(-2);
maxStack.push(0);
maxStack.push(-3);
maxStack.getMax();   --> 返回 0.
maxStack.pop();
maxStack.top();      --> 返回 0.
maxStack.getMax();   --> 返回 0.
maxStack.pop();
maxStack.getMax();   --> 返回 -2.

**思路**：

```java

class MaxStack {
	
	Stack<Integer> data, maxStack;

    /** initialize your data structure here. */
    public MaxStack() {
    	data = new Stack<>();
    	maxStack = new Stack<>();
    }
    
    public void push(int x) {
    	data.push(x);
    	if(maxStack.isEmpty() || maxStack.peek() <= x) {
    		maxStack.push(x);
    	}
    }
    
    public void pop() {
    	int x = data.pop();
    	if(!maxStack.isEmpty() && maxStack.peek() == x) {
    		maxStack.pop();
    	}
    }
    
    public int top() {
    	return data.peek();
    }
    
    public int getMax() {
    	return maxStack.peek();
    }
}
```



## 49. 场景题：分布式生成数据

**题目**：

分布式多个机器生成id，如何保证不重复

**思路**：

* 使用 redis、数据库获取共同 id
* 使用机器码进行 id 的生成



## 50. B+树和红黑树（未完成）

**题目**：

B+树和红黑树， 红黑树和一般的平衡二叉树，增、删、改、查的过程和效率、时间复杂度 

**思路**：

暂且搁置



## 51. 找出和为 k 的数对

**leetcode 原题链接**：[剑指 Offer 57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

**难度级别**：简单

**题目**：

输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

**示例1**：

>输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]

**示例2**：

输入：nums = [10,26,30,31,47,60], target = 40
输出：[10,30] 或者 [30,10]

**限制**：

* 1 <= nums.length <= 10^5
* 1 <= nums[i] <= 10^6

**思路**：

双指针

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int i=0, j=nums.length-1;
		while(i<j) {
			int k = nums[i] + nums[j];
			if(k>target) 
				j--;
			else if(k<target)
				i++;
			else {
				return new int[] {nums[i], nums[j]};
			}
		}
		return new int[2];
    }
}
```



## 52. 二叉树各层节点数

**题目**：

返回二叉树各层节点数，使用递归和非递归方法，并说明时间复杂度和空间复杂度

**思路**：

```java
// 递归方法,使用 map 来保存每一层的节点，时间复杂度为 o(n)，空间复杂度为 o(n)
class Solution {

	Map<Integer, Integer> map = new HashMap<>();
	
	public int[] nodeCount(TreeNode root) {
		nodeCount(root, 0);
		int[] res = new int[map.size()];
		for(Integer i:map.keySet()) {
			res[i] = map.get(i);
		}
		return res;
	}
	
	public void nodeCount(TreeNode node, int level) {
		map.put(level, map.getOrDefault(level, 0) + 1);
		if(node.left != null)
			nodeCount(node.left, level+1);
		if(node.right != null)
			nodeCount(node.right, level+1);
	}

}
```

```java
// 非递归方法，额外使用一个 queue 来层序遍历二叉树，时间复杂度为 o(n)，空间复杂度为 o(n)
class Solution {

	static Map<Integer, Integer> map = new HashMap<>();
	
	public int[] nodeCount(TreeNode root) {
		if(root == null)
			return new int[0];
		Queue<TreeNode> queue = new LinkedList<>();
		queue.add(root);
		int level = 0;
		while(!queue.isEmpty()) {
			int size = queue.size();
			for(int i=0;i<size;i++) {
				TreeNode t = queue.poll();
				if(t.left != null)
					queue.add(t.left);
				if(t.right != null)
					queue.add(t.right);
			}
			map.put(level, size);
			level ++;
		}
		
		int[] res = new int[map.size()];
		for(Integer i:map.keySet()) {
			res[i] = map.get(i);
		}
		return res;
	}

}

```



## 53. 输出下一个更大的数字

**题目**：

给定一个正整数，找到由相同数字组成的下一个更大的数字

**示例**：

>输入：314
输出：341

**思路**：

从末尾开始，尽量从低位开始将大的换到前面。比如 127374, 4 和 3 交换比 7 和 3 交换要好。

```java
class Solution {
	
	public int nextNumber(int num) {
		char[] chars = String.valueOf(num).toCharArray();
		int length = chars.length;
		outter: for(int i=length-1;i>0;i--) {
			for(int j=i-1;j>=0;j--) {
				if(chars[i] > chars[j]) {
					char temp = chars[i];
					chars[i] = chars[j];
					chars[j] = temp;
					break outter;
				}
			}
		}
		return Integer.parseInt(new String(chars));
	}
}
```



## 54. 输出字符串数组？（题目看不懂）

**题目**：

（这是原博的描述）
算法：输入List<String>，删除当中形如”1_”的，返回原来的List (2)

emmmm......地球人表示看不懂



## 55. 缺失的第一个正数

**leetcode 原题链接**：[41. 缺失的第一个正数](hhttps://leetcode-cn.com/problems/first-missing-positive/)

**难度级别**：困难

**题目**：

给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。

**示例1**：

>输入: [1,2,0]
输出: 3

**示例2**：

>输入: [3,4,-1,1]
输出: 2

**示例3**：

>输入: [7,8,9,11,12]
输出: 1

**思路**：

用位图法，遍历数组将值为 i 的数字转移到下标为 i-1 的位置。再次遍历查看不对的值即可。
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; ++i) {
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                int temp = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            }
        }
        for (int i = 0; i < n; ++i) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return n + 1;
    }
}
```

















