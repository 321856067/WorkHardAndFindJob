## 字节跳动面经

[字节跳动1-3面](https://www.nowcoder.com/discuss/427194)

**一面**：

1、抽象类和接口

网上有很多奇怪的答案，比如说“接口中只能有抽象方法”，这些说法过时了，1.8以后以我为准。 
区别有很多，比如说：
* 抽象类用 abstract class，接口用 interface；
* 抽象类中属性可以是任何修饰符修饰的，接口中属性只能是 public 或者没有修饰符；
* 抽象类中的方法可以是任意访问修饰符，接口中方法只能是 public static 或者 static；
* 抽象类可以有构造方法，接口不能有；
* 实现的话，抽象类依靠子类使用 extends 继承，接口则用 implements；
* 一个类最多只能继承一个类，但是可以实现多接口；
* 抽象类被继承时体现的是 is-a 关系，接口被实现时体现的是 can-do 关系。

2、成员变量和方法的区别

成员变量是属性，体现了对象有什么特性，成员方法是行为，体现了对象能干什么。

3、内部类

内部类有四种：成员内部类、静态内部类、方法内部类以及匿名内部类
[Java基础复习(四、三大特性) - 内部类](https://blog.csdn.net/kirito_lewis/article/details/105953550#innerclass)

4、基本数据类型，拆箱装箱

七种，byte、short、int、long、float、double、char。
拆箱装箱是因为他们的包装类型，可以运行下面代码：
```
int i = 3;
Integer j = i;
```
这是因为编译器自动将这段代码变成了调用`Integer.valueOf()`方法。还有`intValue()`方法的使用。

5、java的同步和并发

同步就是单线程操作，没啥好说的。
并发就是多线程操作，通过线程来完成多任务的操作。
创建线程的三种方式：1、继承`Thread`类；2、实现`Runnable`接口；3、实现`Callable`接口。
优缺点：
(1)、采用实现Runnable、Callable接口的方式创建多线程时，
优势是：
线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。
在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
劣势是：
编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。
(2)、使用继承Thread类的方式创建多线程时，
优势是：
编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。
劣势是：
线程类已经继承了Thread类，所以不能再继承其他父类。
(3)、Runnable和Callable的区别
[1] Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。
[2] Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。
[3] call方法可以抛出异常，run方法不可以。
[4] 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。

6、HashMap的底层实现和扩容机制等

底层实现，bucket + linkedlist/红黑树
扩容机制：
当`size > threshold (该字段记录下一次扩容的大小，capacity * load factor)`时，调用 `resize()`方法，Map 容量乘以 2，以保证容量是 2 的幂次，然后将原来的节点放到新的 bucket 中。

7、GC 垃圾回收机制

如果是问垃圾回收策略的话，有以下三个：
(1)复制回收算法
此种方法通过依次扫描区域所有的可达对象，然后将其复制到另外一片区域保存起来，再将其现在正在使用的区域内存全部清空，此方法的优点在于方便快捷，只需要便利出所有的可达对象即可，而且不会出现碎片化内存。但是缺点也很明显，复制对象需要计算成本，此外需要准备一个额外相同Eden区域大小的内存空间，也是一笔巨大的开销。
(2)标记清除法
这种方法首先遍历整个区域中的对象，然后标记所有的可达对象，再将所有内存中未被标记的对象全部清除。主要缺点在于会产生大量的碎片内存。
(3)标记整理法
这种方法集上面两种算法的优点于一身，首先遍历整个空间对可达对象进行标记，然后再将所有可达对象整理到一起去，最后清除掉不可达的对象，达到GC回收清理内存的目的。（这个跟复制回收算法有区别？？？）

8、Java 编译后的字节码文件结构是怎样的？

（这谁记得住啊。。。）首先是 4 个字节的魔数(用于查看文件是否能运行，因为后缀名可以随便改)。2 个字节的次版本号，2 个字节的主版本号（版本号用于判别虚拟机是否可以运行当前版本，可以向下兼容）。2 个字节常量池计数值，（常量计数值 - 1）* （对应类型的大小）个字节的常量池大小，大小跟常量类型有关。然后是 2 个字节的访问标志（是类还是接口，是不是 public 类， 是不是 abstract 类型，有没有被声明成 final 等等）。2 个字节的类索引（确定全限定名）和 2 个字节的父类索引（父类的全限定名）。2 个字节的接口计数值，（接口数 * 2）个字节的接口。2个字节的字段计数值，（字段计数值 * 对应类型的大小）个字节的字段。2 个字节的方法计数值，（方法计数值 * 对应方法的大小）个字节的方法。

9、算法：每k个反转链表，leetcode原题。

这题在 LeetCode 中算 hard 的啊。。。
```
	public ListNode reverseKGroup(ListNode head, int k) {
	    ListNode dummy = new ListNode(0);
	    dummy.next = head;

	    ListNode pre = dummy;
	    ListNode end = dummy;

	    while (end.next != null) {
	        for (int i = 0; i < k && end != null; i++) end = end.next;
	        if (end == null) break;
	        ListNode start = pre.next;
	        ListNode next = end.next;
	        end.next = null;
	        pre.next = reverse(start);
	        start.next = next;
	        pre = start;

	        end = pre;
	    	}
	    return dummy.next;
	    }

	    private ListNode reverse(ListNode head) {
	    ListNode pre = null;
	    ListNode curr = head;
	    while (curr != null) {
	        ListNode next = curr.next;
	        curr.next = pre;
	        pre = curr;
	        curr = next;
	    }
	    return pre;
	}
```

**二面**：

1、计算机网络组成原理

OSI模型和TCP/IP模型以及两者的综合五层模型

2、计网

a、五层结构有哪几层？哪一层实现最麻烦？

物理层、数据链路层、网络层、传输层、应用层。应用层实现最麻烦，因为不同应用的协议

b、TCP 是干什么的？为什么有了 TCP 还需要 IP 等协议？TCP 可靠传输如何实现？三次握手?为什么需要三次？

TCP是传输层的协议，用于端到端的报文段的可靠传输。
IP协议是网络层的，用于网际互联，注重的层次不一样，因此需要IP这些协议。
通过三次握手构建稳定链接。三次握手四次拜拜。如节点A和节点B之间传输数据，三次握手分别是：1、节点A发送到节点B，表示节点A发送功能没问题；节点B收到数据后将结果发送到节点A，表示节点B发送功能和接收功能都没问题；节点A收到数据后将结果发送给节点B表示自己接收功能没问题

c、DNS 解析的过程，为什么目的是获得 IP 还要用 URL？直接用 IP 不好吗？根服务器在哪里？

(1)先找浏览器缓存中有没有，有则返回没有则下一步；
(2)再找系统缓存（Host文件）中有没有，有则返回没有则下一步；
(3)在路由器缓存中查找，有则返回没有则下一步；
(4)到互联网服务提供商DNS缓存中查找（电信、移动），有则返回没有则下一步；
(5)到根域名服务器的区域文件记录中查找，有则返回没有则将其管辖范围内顶级域名服务器IP告诉本地DNS服务器；
(6)顶级域名服务器查看区域文件记录，有则返回没有则将其管辖范围内主域名服务器的IP告诉本地DNS服务器；
(7)主域名服务器查找自己缓存，有则返回没有则进入下一级域名服务器查找，直到找到正确记录；
(8)本地域名服务器把返回的结果保存到缓存，并返回客户端。
之所以需要URL不用IP是因为IP不好记，URL比较好记。
根服务器分布在全球，一共为13台原有根+25台v6辅助根。中国有4台，一台主根和三台辅根。

d、HTTP 和 HTTPS，HTTPS 如何加密？

HTTP是超文本传输协议，用于Web浏览器和服务器之间传递消息，以明文方式交换数据，因此不安全。
HTTPS是安全套接字层超文本传输协议，在HTTP的基础上添加了SSL协议，依靠证书来验证服务器的身份，并提供了通信加密。

3、OS

a、磁盘空间空闲管理

[Linux磁盘空闲空间调度管理](https://blog.csdn.net/roger_ranger/article/details/77689709)

4、数据库

a、数据库索引是什么？为什么选择 B+ 树？

索引就是为了避免全表查找，利用特定列形成B+树从而加快搜索的速度。
选用B+树是因为稳定且好用。不用Hash数组是因为在分组、排序等操作时，复杂度会退化成O(n)，而B+树还是O(logn)。不用二叉查找树是因为B+树的范围查找比二叉查找树优秀，不需要中序回溯，并且改进后查询全部数据时不需要中序遍历而是直接用链表。
总的来说就是：
（1）适合磁盘存储，能够充分利用局部性原理，磁盘预读；
（2）树高度较小，能够存储大量数据（相对于二叉树而言）；
（3）索引本身占用的内存很小；
（4）能够很好的支持单点查询，范围查询，有序性查询。

5、算法：

a、给一个整数数组，找右边元素减左边元素的最大差值

LeetCode 股票题解：
```
	public int maxProfit(int[] prices) {
		int[] values = new int[prices.length-1];
		// 将每天的价格变成每天相比前一天的变化量
		for(int i=0;i<prices.length-1;i++) {
			values[i] = prices[i+1]-prices[i];
		}
		// 求最大子序列和
		int res = values[0];
		for(int i=1;i<values.length;i++) {
			values[i] += Math.max(values[i-1], 0);
			res = Math.max(res, values[i]);
		}
		return res>0?res:0;
    }
```
b、旋转数组
```
	public void rotate(int[] nums, int k) {
		int[] a = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            a[(i + k) % nums.length] = nums[i];
        }
        for (int i = 0; i < nums.length; i++) {
            nums[i] = a[i];
        }
    }
```

**三面**

1、关于Linux和Android的了解？？？

2、代码环节

a、线程内部修改外部变量，外部变量用static和voaltile修饰时情况是怎么样的。去除这些关键字，如何实现变量一经修改，外部打印语句就可以马上打印新的值。

b、算法题：二进制反转

c、二叉树的前序遍历的Iterator

3、职业规划
（这个感觉讲的不是很清楚）