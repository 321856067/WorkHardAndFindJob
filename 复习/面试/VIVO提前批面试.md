## VIVO提前批面试
面经从正经到不正经开始记录

### [Vivo java开发安卓方向 秋招提前批 一面](https://www.nowcoder.com/discuss/437674)

1.自我介绍

2.Java的深拷贝和浅拷贝

对于基础类型来说，没有深拷贝和浅拷贝的区别，因为对于基础类型来说，都是值传递的。而对于引用类型来说，浅拷贝只是简单对地址进行了复制，而没有对对象进行完整的数据复制，而深拷贝则是完全新建了一个跟原来对象相同的对象，而不是仅仅的地址复制。深拷贝有两种方法，一种是自己根据对象类进行分析，然后对属性进行层层复制，另一种是通过 IO 方法。

3.介绍反射机制，缺点是什么？

反射是通过获取类的 class 文件，从而动态地进行创建对象，赋值，方法调用等功能的机制。
优点是运行时进行类型的判断，动态加载类，很灵活。缺点是性能比较比较差，比正常调用要慢很多，并且安全性不行，动态地改变类的属性会增加安全隐患，比如说我们想要对 private 修饰的成员变量进行赋值，但是我们不确定有没有对应的 set 方法，我们可以通过修改 accessible 来修改类属性的访问权限，从而直接赋值。但是这样会造成类属性访问权限的失效，对 private 修饰的成员变量而言，这是非常不安全的。

4.类加载机制

类加载分为 加载 -> 连接（验证 - 准备 - 解析） -> 初始化

加载阶段是程序员能动性最大的一个阶段，在这个阶段还有类加载器（启动类加载器、扩展类加载器、应用程序加载器）、“双亲委派机制”的内容，以及根据字节流获取方式的不同衍生出来的方法。
加载阶段主要完成三件事情：
* 通过全类名获取定义此类的二进制字节流
* 将字节流所代表的静态存储结构转换成方法区的运行时数据结构
* 在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口

验证阶段主要完成四部分验证：
* 文件格式验证（验证字节流是否符合 Class 文件的规范，比如说魔数，虚拟机版本）
* 元数据验证（对字节码描述的信息进行语义分析，保证信息符合 Java 语言的规范。比如说是否有父类）
* 字节码验证（通过数据流和控制流分析，确定程序语义是合法的。比如保证任意时刻操作数栈和指令代码序列都能配合工作）
* 符号引用验证（确保解析动作能正确执行）

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，有两点要注意：
* 此时进行内存分配的仅包括类变量，而不包括实例变量；
* 初始值通常情况下是数据类型默认的零值。特殊情况：比如说`static final int value=111`，此时准备阶段赋值为`111`；

解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。

初始化阶段是执行类构造器`<clinit>()`方法的过程，有且只有六种情况下，必须对类进行初始化：
* 遇到`new`、`getstatic`、`putstatic`、`invokestatic`四条字节码指令时，如果没有进行过初始化，则需要先触发其初始化阶段；
* 使用反射的时候；
* 初始化类的时候，如果父类还没有初始化则先触发父类的初始化；
* 初始化主类；
* 如果一个`MethodHandler`实例最后的解析结果是`REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`、`REF_newInvokeSpecial`四种类型的方法句柄时，且对应的类没有进行过初始化时；
* 当一个接口中定义了 JDK8 新加入的默认方法时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化

5.堆和栈的区别

如果是说 Java 内存模型的堆和栈的话：
堆是线程共享的，用于存放对象实例，栈分为虚拟机栈和本地方法栈，虚拟机栈用于记录方法的调用，局部变量等信息，本地方法栈为本地方法提供服务。

如果是说数据结构的话：
栈先进后出，而堆则符合大根堆、小根堆的特性

6.介绍一下锁

锁是一种多线程情况下的临界资源，在多线程的情况下，一个线程只有在持有锁的情况下，才能使用 CPU 运行代码，否则只能等待其他线程放弃锁的持有。比如说 Java 中我们常用的 synchronized 关键字，`ReentranceLock`，前者使用指令实现 monitor 的锁机制，后者使用 AQS，实现代码级别的锁机制。

7.出现死锁如何解决

出现死锁，首先要找到出现死锁的原因，然后采取合适的方式进行锁的选择和分配。比如说如果一个方法 A 持有锁去调用另一个需要锁的方法 B，此时就会出现死锁，这种情况下只需要使用可重入锁就能解决问题。比如说线程 A 持有锁 n，需要获取锁 m，而另一个线程 B 持有锁 m，需要获取锁 n，这样子也是死锁，如果是读写场景，那么可以使用读写锁进行分离。锁的种类很多，可以根据实际的业务场景进行选择。

8.线程和进程的区别

首先讲进程，进程是一个应用程序分配资源的最小单位，我们可以认为一个应用程序就是一个进程。而线程则是进程的细分，充分利用多核 CPU 的资源，将进程的资源分成多个线程的资源，从而加快应用程序的处理速度，在操作系统中，我们是看不到线程的，只有通过一些工具，比如说 jstack，才能看到线程。

9.如何在 Java 中实现线程

如果说是创建线程，那么有三种方式：
* 继承`Thread`类；
* 实现`Runnbale`接口;
* 实现`Callbale`接口，使用`Future`;

10.如何解决内存泄漏的问题

内存泄漏问题主要是一些对象长时间不被使用，但是由于存在引用，可达性分析ok的情况，GC 无法回收这些对象。这种情况下，对一些内存使用比较大、而且存在时间比较短的对象，我们可以使用弱引用或者软引用。

11.如果 A 引用 B，B 引用 A，如何回收这两个对象

这实际上是垃圾回收策略的其中一种，就是判断引用数量是否为 0。这样如果存在互相引用的情况，那么 GC 没办法判断的。这就涉及到了另一种，也是现在商用虚拟机最常用的一种方法，可达性分析。可达性分析就是设立了一连串的 GC roots，然后由这些 GC roots 进行深度遍历，达到的都是有用的，没达到的就会打上标签，进入到一个队列中等待执行`finalize`方法。

12.JVM 如何进行垃圾回收

那不就是上面的问题么

13.传输层有哪些协议

TCP 和 UDP

14.TCP 协议的三次握手为什么不能是两次

因为两次达不到建立稳定链接的目的。第一次握手，A 发送给 B，测试 A 的发送能力没有问题；第二次握手，B 发送给 A，表明 B 接收功能没有问题，测试 B 的发送功能；第三次握手，A 发送给 B，表明 B 的发送功能和 A 的接收功能没有问题。两次没有办法做到。

15.在1万个数据中查找中间的数据，A方法需要2秒钟，B方法需要5秒钟。在100万个数据中查找，A方法需要50秒，B方法需要30秒，如何衡量这两种方法的性能优劣

嗯，看情况选择方法吧。没有一种方法是普遍使用于任何场景的，就像没有一段代码是能够解决任何问题的。身为程序员应当有能力判断在哪种业务场景下，选择哪种方法是更加优势的。比如说在业务比较少的情况下，要在在1万个数据中查找中间的数据，那么显然选择 A 方法，如果要在在100万个数据中查找，那么选择 B 方法。如果说数据持续增长，且以后 B 的方法表现一直要优于 A 方法，那么为了节约发布版本的时间，一直采用 B 方法，牺牲前期一些 A 方法可以节约的时间，也不是不可以。

-----------

### [vivo Java面试凉经](https://www.nowcoder.com/discuss/438148)

1.自我介绍

略

2.类加载器

类加载器有三种：
* 系统类加载器。系统类加载器加载的范围是 JAVA_HOME/lib 下的类
* 扩展类加载器。扩展加载器加载的范围是 JAVA_HOME/lib/ext 下的类
* 应用程序加载器。应用程序加载器加载的范围是用户类路径下的类，包括用户自己实现的类加载器都是继承这个类

双亲委派机制：
双亲委派机制是对类加载器加载类时做的一个处理，为的是防止类的重复加载。在加载器加载类的时候，首先看自己有没有加载过这个类，如果没有的话，将这个类委派给自己的父加载器进行加载，父加载器如果没有父父加载器，且能加载，那就父加载器进行加载，如果不能加载则子加载器自己进行加载。

3.jdk

不知道什么意思。。。jdk 是 Java 开发工具包，全称是 Java developement Kit，他包含了 JRE 中所有的内容以及一些测试工具。

4.红黑树

这个不太了解。。。[红黑树](http://dongxicheng.org/structure/red-black-tree/)

5.HashMap 线程安全

HashMap 操作不是线程安全的，但是他有一个 entrySpiliterator，这个将 HashMap 给拆分了，在多线程进行迭代的时候会报并发操作异常，这里是安全的。如果将整个 HashMap 用 synchronized 进行加锁当然也是线程安全的，但是这样子会导致访问不同 bucket 也会加锁，其实没有必要，降低了并发的性能。
推荐使用 ConcurrentHashMap，这个是线程安全的。在 HashMap 的基础上，对 bucket 进行 synchronized 加锁，1.8 以前是使用分段锁，现在其实也算是一种分段锁把。

6.synchronize和lock

synchronized 关键字使用的是指令级别的 monitor。 lock 使用的是 AQS，是通过代码级别的加锁。 synchronized 和 lock 都可以实现可重入锁。synchronized 关键字只能修饰方法、变量或者类和代码块，而 lock 则比较灵活，只需要使用 lock() 和 unlock() 就好了。

7.arraylist，linklist区别

区别在于存储元素的介质不同。ArrayList 使用的是数组，因此随机访问效率比较高，但是遇到扩容的时候，时间复杂度就高了。LinkedList 使用得是链表，因此查询的的时候时间复杂度就高了，但是由于是链表，在添加节点、扩容的时候时间复杂度都是常数级的。

8.数据库全局锁

这个不知道。
以下摘自博客[（10）数据库的各种锁：全局锁、表锁和行锁](https://blog.csdn.net/hanpeiyu1995/article/details/90180385)
全局锁就是对整个数据库实例加锁。 MySQL 提供了一个加全局读锁的方法，命令是Flush tables with read lock (FTWRL) 。这样就让整个库处于只读状态，之后其他线程以下语句会被阻塞：
* 数据定义语言DDL(Data Definition Language)，包括建表，定义修改表结构等
* 数据操纵语言DML(Data Manipulation Language)　　包括数据的增删改、插入等
全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。但是加全局锁有两个弊端：
* 在从库上备份，那么从库不能执行主库同步过来的 binlog，导致主从延迟
* 如果你在主库上备份，那么在备份期间都不能执行更新
为了克服加全局锁的弊端。**官方自带的逻辑备份工具是 mysqldump使用参数 –single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。然而一致性读是好，但前提是引擎要支持这个隔离级别。所以， single-transaction 方法只适用于所有的表使用事务引擎的库**，比如，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。

9.索引优化

（不太懂）对那些经常查询的列进行索引，而那些不经常查询的列就没有必要查询了。
合理使用索引，比如说普通索引啊、联合索引啊、全文索引啊。

10.新生代，老年代

分代思想的体现：一些对象创建出来很快就会被回收，一些对象创建出来很久也不会被回收，因此为了垃圾回收器的效率，将堆分成了新生代和老年代，将那些朝生夕死的对象放到新生代中，增加垃圾回收器在新生代的回收次数，将那些很久也不会被回收的对象放进老年代甚至永久代中，减少垃圾回收器在老年代的回收次数

11.JVM 内存

是问内存模型嘛？
线程独占：程序计数器、虚拟机栈、本地方法栈
线程非独占：堆、方法区（元空间）

12.mysql查询一亿数据怎么办

正确建立索引
分表分库
使用缓存、主从数据库等技术缓解服务器压力

13.内存无法装下的文件查词频

分开存储，然后进行分块处理
（这个比内存无法装下的进行排序简单多了 -- 外排序）

14.线程池实现的几种方式

这个问题是要问线程池的种类吗？
具体的名字记不得了，主要有：
* 只有有限个核心线程，使用 LinkedBlockingQueue，固定线程池
* 只有一个核心线程没有非核心线程的线程池，使用的是 LinkedBlockingQueue
* 没有核心线程，只有无限个非核心线程，使用得是 SynchronousQueue

拒绝策略：
* 直接抛错
* 丢弃当前任务
* 丢弃最旧的（下一个要执行的）任务
* 交给原线程进行执行

15.sql场景题

略

16.concurenthashmap

ConcurrentHashMap 实际上就是在 HashMap 的基础上添加了分段锁，1.8 以前是使用 SegmentLock，现在是对 bucket 的每一个格子进行 synchronized 加锁。

-----------

### [vivo Java提前批面经](https://www.nowcoder.com/discuss/437763)

1.Jvm 双亲委派，说出每个类加载器

JVM 双亲委派就是类加载器在加载类时候，首先检查这个类有没有加载过，然后去委托父加载器去加载，如果父加载器在自己的搜索范围内没有找到这个类，也就是父加载器不能完成类加载任务，那么子加载器才会去完成加载任务。
类加载器有三种：启动加载器（只加载器\lib目录下以及 bootClassPath 指定的目录下的类）、扩展类加载器（用于加载\lib\ext目录下的，以及系统变量所指定的）、应用程序类加载器（负责加载用户类路径下的所有类库）

2.JVM 的 GC 老年代和新生代

这个不太熟。在新生代中，每一次 GC 都会有大量对象被清除，在多次 GC 后仍存在的对象会晋升到老年代中。老年代中 GC 次数比较少，都是一些存活的比较久的对象，他们被回收几率比较低。分代是为了兼顾回收空间和效率的做法。

3.数据库

(1)多个表多个数据如何去重和条件查询

不太懂什么意思。。。如果是我的话，我会建立一个缓存，将所有节点放到缓存中构建成一个查找树，加快查询，也不会有重复

(2)数据库如何优化查询

建立索引

(3)在不利用主键和索引的情况下如何提高查询效率

建立分区

4.四次挥手的 timeout 是在哪个阶段

第四个阶段，即服务器发出释放连接报文，客户机接收到以后发出确认，然后等待计时器设置的时间才进入连接关闭状态

5.说说 hashmap

看过源码所以比较了解。Hashmap 有一个数组，用来存储 bucket，每次我们 put 的时候，都会对键进行计算（这里面使用键的 hashcode 和 hashcode 的位移以后的值进行或运算）然后和数组长度进行与运算得到 bucket 的位置。在没有达到特定值的时候，每个 bucket 其实是一个链表，到了特定值以后，就会使用红黑树进行存储。当元素个数到达阈值的时候，会使用当前容量和装载因子进行一次扩容。

6.了解生产者和消费者模型嘛？自己设计一个

了解。生产者只负责生产，生产后的元素可以放到队列中，也可以放到消息通道中，消费者只负责消费，一旦空闲就会从队列或者通道中获取元素。

7.说说如何在亿万数据中统计一些数据的出现次数

没懂什么意思。。。布隆过滤器？

8.说说 lock 和 synchronized 的区别，那你如何不用 jdk 的锁和 lock 实现一个代码块的原子操作

有区别，lock 更加灵活，使用得是软件层面的 AQS 保证锁，synchronized 使用的是指令层面 monitor，只能对方法、属性和代码块进行加锁。
用 synchronized 修饰代码块，或者使用 unsafe 加 volatile。

---------

### [vivo提前批JAVA工程师Android方向APP](https://www.nowcoder.com/discuss/437732)

1.tcp和udp区别？
追问：udp端口段是怎么设置的？

TCP 建立可靠连接，保证了数据的有序、安全传输，首部有 20B，比 UDP 多了拥塞控制、流量控制等功能。UDP不建立连接，不能保证数据的可靠传输，首部只有 8B，仅在 IP 数据报的基础上加了差错检测和复用和分用。
端口段？什么意思？16位的源端口号 + 16位的目的端口号？

2.tcp三次握手协议

A -> B
B -> A
A -> B

![截屏2020-06-10 下午2.07.10](/Users/y1271752959m/Documents/WorkHardAndFindJob/复习/面试/images/截屏2020-06-10 下午2.07.10.png)

3.hashmap在插入一个元素时，数据结构发生了什么变化？

先找到对应的 bucket 找到链表的头结点，然后加进去，如果链表长度超出一定长度，就会将链表转化成红黑树。最后判断当前元素是否超过阈值，超过的话就扩容。

4.内存泄露和内存溢出有什么区别？

内存泄露是指一些长期不用的对象由于存在对他的引用，导致 GC 无法回收该对象而造成的内存浪费。
内存溢出是指对象过多导致内存不够用。
内存泄漏发生了不代表也会发生内存溢出，反过来，内存溢出也不一定会发生内存泄漏的问题。

5.JAVA多线程开发时怎么保证线程安全？

通过对临界资源加锁


6.Android进程间通信都有那些手段？

不太懂安卓，如果是 Java 的话可以用 wait、notify、notifyAll 方法，或者使用 Lock 中的 Condition


7.Activity的启动模式都有哪些？分别是怎么回事？

不懂。。。

8.单例设计模式怎么保证线程安全？

方法1：使用饿汉模式直接加载，这样的方法会有一个问题，就是长时间不用会浪费内存
方法2：懒汉加 synchronized，缺点是多线程抢锁会浪费时间
方法3：使用静态内部类对实例进行创建，实例用 static final 修饰，实例只会在内部类被调用的时候完成初始化，而 static final 则保证了实例只会被初始化一次。
方法4：使用枚举的方法

9.责任链设计模式是怎么回事？

责任链设计模式就是通过建立一个链表，然后元素从头结点开始往下传，层层往下传递，直到遇到可以处理的责任人。比如说领导签署文件，节点从职员开始直到大老板，职员先接受文件，发现自己没权限处理，然后传给经理，经理发现自己没权限处理，然后交给总经理，总经理能处理，就结束了，否则交给大老板。

10.内部类和静态内部类的区别？

普通内部类也叫成员内部类，定义如同外部类的成员一样定义。成员内部类可以调用外部类的属性和方法，即使是 private 修饰的变量，而外部类只能通过实例化内部类的形式调用内部类的属性和方法，实例化的方式为 `外部类对象.new 内部类构造方法`。
静态内部类时被 static 修饰的内部类，静态内部类无法直接访问外部类的非静态成员属性和方法，但是可以通过实例化外部类的方式进行访问。使用静态内部类时，不需要通过外部类实例的方式进行对内部类的实例化，直接 new 即可。

---------

### [vivo 安卓提前批面经](https://www.nowcoder.com/discuss/437996?channel=666&source_id=home_feed)

1.fork命令 如何区分父子进程

啊？linux 下的 fork嘛？这个不了解。倒是知道 Java 中的 fork/join 模式

2.websocket了解吗

还好吧，这是一种应用层的协议，和 HTTP 相比，允许服务器主动推送消息给客户机，实现双方的平等会话，而传统的 HTTP 只能由客户机主动发起请求，从服务器获取数据。比如说之前四川一款的手机应用，当出现地震或者灾害的时候，服务器会主动向附近的人发送消息提醒，像这种情况你用 HTTP 肯定不合适了，因为用户不可能无时无刻去不断的查询。

3.synchronized 和lock

lock 更加灵活，使用得是软件层面的 AQS 保证锁，synchronized 使用的是指令层面 monitor，只能对方法、属性和代码块进行加锁。

4.restful

restful 是一种网络应用程序的设计风格和约束条件，客户端使用四个操作方式：get、post、put 和 delete 来实现对资源的操作，其中 get 表示获取， post 表示上传或新增，put 表示修改，delelte 表示删除。

5.什么是引用和指针的区别

引用不能随便移动，不会引起内存泄漏，指针可以随便移动（通过 ++、--），会引起内存泄漏。

6.进程通信方法

管道、消息队列、信号量、共享存储、socket 和 Streams

7.内核和用户态

操作系统方面的不太懂诶

---------

### [Vivo秋招（提前批）](https://www.nowcoder.com/discuss/437690)

1.谈项目，自己负责的模块以及实现的功能。

略

2.聊一下对Dubbo的理解，以及选用Dubbo的原因，为什么不用springCloud？

略

3.项目中遇到的问题？如何解决的？

略

4.Hadoop用过么？大概介绍一下

没

5.Zookeeper所在的机器宕机后能否进行服务调用？服务调用端的服务列表如果是你用java实现，你会选什么容器？

前面的不会。后面的使用`ConcurrentHashMap` 

6.HashMap如何保证线程安全？各种实现方式下为什么选用ConcurrentHashMap？

用锁或者 synchronized 关键字在使用 HashMap 时加锁。`ConcurrentHashMap`线程安全

7.你的优势在哪里？

略

8.反问

--------

### [VIVO2021提前批感觉凉凉](https://www.nowcoder.com/discuss/437673)

1.先做个自我介绍

略

2.介绍下你的项目

略

3.你项目用到了反射讲一讲

略

4.说一下Java的GC

如何判断是否需要回收：引用计数器和可达性分析
如何回收：标记-清理，标记-复制，标记-整理

5.==和equals

前者判断地址是否相等，后者使用 Object 类的 equals 方法，也可以自己重写

6.Integer 2  int 2相等吗

不相等，一个是包装类，一个是基础类型。但是他们有自动拆箱装箱的方法

7.你有什么要问的？

略

---------

### [Vivo提前批面经（后端开发）](https://www.nowcoder.com/discuss/437621?type=0&order=0&pos=87&page=1&source_id=discuss_center_0&channel=666)

1.自我介绍；（介绍完项目就说你们咋都做的秒杀呀？学长学姐告诉你们的吗？）

略

2.怎么学的java；

略

3.总结自己优劣；

略

4.研究生干了啥；

略

5.为什么要做秒杀项目；

因为秒杀项目最主要就是高并发情况下的架构设计，我觉得很有意义。因为现在手机越来越普遍嘛，购物什么的手机一下子就能搞定，而不用盯着电脑，这样就决定了现在购物的并发量远远超过以前电脑的时候。秒杀项目解决的在如此高并发的场景下，实现业务的正常运行。

6.JVM垃圾回收，500G的内存全部分配给堆内存会发生什么；

一次垃圾回收时间特别长

7.给你爷爷奶奶讲明白什么是进程，线程，以及死锁

略

