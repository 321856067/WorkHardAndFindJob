# 老是忘的知识点

## 1.进程间通信的方式

进程间通信主要有以下几种方式：
* 管道：
	* 只支持半双工通信
	* 只能在父子进程或者兄弟进程间使用
* FIFO：去除了管道只能在父子进程中使用的限制，常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据
* 消息队列：相比FIFO具有以下优点
	* 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
	* 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
	* 杜金城可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收
* 信号量：是一个计数器，用于为多个进程提供对共享数据对象的访问
* 共享存储：
	* 允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC
	* 需要使用信号量来同步对共享存储的访问
	* 多个进程可以将同一个文件映射到他们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段
* 套接字：与其它通信机制不同的是，它可用于不同机器间的进程通信。

## 2.TCP 中 time_wait 和 close_wait 产生的原因

![TCP 状态转换图1](https://uploader.shimo.im/f/OLBLXAmPKYeOjD2l.png!thumbnail)

![TCP 状态转换图2](https://uploader.shimo.im/f/QrRaIKELGM84hOb4.png!thumbnail)

**time_wait 产生的原因：**
客户机在发起关闭连接后的第四次挥手时，客户机收到服务器发送的 FIN 报文段，然后客户机发出 ACK 并进入 time_wait 状态。在这个状态下，如果客户机发出的 ACK 丢失，那么由于 TCP 的重传机制，服务器会重发 FIN，此时客户机还能重发 ACK。如果没有这个状态，那么客户机直接释放连接后，如果发出的 ACK 丢失，等到客户机重新受到服务器发出的 FIN 时，就会发出 RST 包使得服务器以为有错误发生。在进入 time_wait 状态后，客户机仍要经过 2 个MSL值才能释放连接。

**close_wait 产生的原因：**
服务器收到了客户机发出的 FIN，但是还没有服务器还没有发出自己这边的 FIN，此时服务器就会进入 close_wait 的状态。可能的原因是服务器正在忙于读或者写，或者在准备关闭前的事情。

## 3.HTTP 协议与 HTTPS 协议的区别？

* (1) https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。
* (2) http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。
* (3) http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
* (4) http 的连接很简单，是无状态的；HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。

## 4.volatile 导致的总线嗅探和总线风暴问题

总线嗅探和总线风暴问题只会出现在**多核处理器**上

**总线嗅探**：
如果对声明了 volatile 的变量进行写操作，JVM 就会想处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存**缓存一致性协议**，**每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置无效状态**，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中。

**总线风暴**：
volatile 修饰的关键字不断刷新导致**每个处理器不断地去进行总线嗅探，太频繁的总线嗅探操作导致总线带宽达到峰值**。

## 5.redis 和 memcache 的区别

* **redis 支持更丰富的数据类型（支持更复杂的应用场景）**：Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。memcache 支持简单的数据类型，String。
* **Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中**。
* **集群模式**：memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.
* **Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型**。

![redis 和 memcache 的区别](https://uploader.shimo.im/f/IFu5Xk1tsON0QkK2.jpeg!thumbnail)

## 6.redis 缓存雪崩和缓存穿透的问题

首先，要了解什么是缓存雪崩和缓存穿透。

**缓存雪崩**：
**缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。**

**解决方案**：
* 保证缓存层服务的高可用性，比如主从、分布式缓存、尽快补上机器
* 在缓存失效后通过加锁或者队列的方式来限流并降级，防止数据库崩坏
* 将持久化保存的数据快速恢复，并在大并发访问前对数据进行预热，以及设置不同的过期时间

**缓存穿透**：
缓存穿透说简单点就是**大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层**。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。

**解决方案**：
* 布隆过滤器，用来判断请求的 key 是否有可能存在，不存在就直接过滤
* 缓存空值。当 key 不存在给他设定一个空值

## 7.redis 并发竞争问题

我们要知道，redis 本身是单线程的，因此 redis 本身不会有并发问题。但是多个进行同时去 set 的时候，会出现顺序问题，比如多客户端同时并发写一个 key，一个 key 的值是1，本来按顺序修改为 2,3,4，最后是 4，但是顺序变成了 4,3,2，最后变成了 2。

在这种场景下，有两种方案：
* （1）分布式锁
* （2）消息队列将并行操作串行化

## 8.数据库和缓存的数据一致性问题

**解决方案**:
当存在更新操作时，先删除缓存，再更新数据库，再更新缓存，并且将请求串行化。但是这样并发效率就降低了


