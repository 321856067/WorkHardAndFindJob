## 面经总结
[面试宝典](https://www.nowcoder.com/tutorial/94/4206176d637541fa92c784a4f547e979)
#### 5月14日总结
[交行一面](https://www.nowcoder.com/discuss/425193)

1、java 中抽象类和接口之间的区别？

网上有很多奇怪的答案，比如说“接口中只能有抽象方法”，这些说法过时了，1.8以后以我为准。 
区别有很多，比如说：
* 抽象类用 abstract class，接口用 interface；
* 抽象类中属性可以是任何修饰符修饰的，接口中属性只能是 public 或者没有修饰符；
* 抽象类中的方法可以是任意访问修饰符，接口中方法只能是 public static 或者 static；
* 抽象类可以有构造方法，接口不能有；
* 实现的话，抽象类依靠子类使用 extends 继承，接口则用 implements；
* 一个类最多只能继承一个类，但是可以实现多接口；
* 抽象类被继承时体现的是 is-a 关系，接口被实现时体现的是 can-do 关系。

2、数据库中 acid 各自代表什么？
* a -> atomicity，原子性，即事务要么全部提交成功，要么失败全部回滚，不能只提交其中一部分
* c -> consistency，一致性，即事务提交前和提交后都要保证处于一致性状态
* i -> isolation,隔离性，即事务和事务之间是互相隔离的，一个事务中的数据和状态不能被另一个事务干扰
* d -> durability，持久性，一旦事务成功提交，那么对应数据的变更就会永久保存到数据库中

3、数据库中常用的函数？

常用
avg() -> 平均值
count() -> 计数
max() -> 最大值
min() -> 最小值
sum() -> 总和
字符串：
concat -> 链接
insert() -> 修改几位的值
lower -> 小写
upper -> 大写
substring() -> 子字符串
日期：
获取当前
返回几天后的日期
...
数学：
取整
随机
...

4、堆和栈的区别

堆：树形结构，有大根堆和小根堆，可以在常数时间内取出最大（小）值，可以在 log(n) 的时间内找值
栈：表型结构，先进后出

[拼多多一面](https://www.nowcoder.com/discuss/424361)

1、Java 的特性，怎么实现多态的，怎么找到子类的方法

三大特性：封装、继承、多态。
（怎么实现的？这是什么问题，问底层？还是有什么机制？）
底层的话，其实就是到方法表中去找指定的方法进行调用。实现机制的话可以是继承、接口等。
（怎么找到子类的方法？什么意思？）编译器中比如说 IDEA 可以找用 findUsage 功能找到。如果说代码中的话，这不太合适，一方面你不知道子类中有没有实现这个方法，另一方面父类调用子类的方法本身也是不合逻辑的，当然静态方法是完全可以的。

2、说说 HashMap，底层是怎么实现的，我们来写一个 HashMap 吧。

[HashMap 源码解读](https://blog.csdn.net/kirito_lewis/article/details/106151884)

3、写个算法题，找出一个字符串的最大合法十进制数

这个就不搞了

4、说说平时用的 Java 锁，底层是怎么实现的？

[Lock - 对锁的一些面试题的总结](https://blog.csdn.net/kirito_lewis/article/details/106186366)

#### 5月21日总结
[字节跳动1-3面](https://www.nowcoder.com/discuss/427194)

**一面**：

1、抽象类和接口

网上有很多奇怪的答案，比如说“接口中只能有抽象方法”，这些说法过时了，1.8以后以我为准。 
区别有很多，比如说：
* 抽象类用 abstract class，接口用 interface；
* 抽象类中属性可以是任何修饰符修饰的，接口中属性只能是 public 或者没有修饰符；
* 抽象类中的方法可以是任意访问修饰符，接口中方法只能是 public static 或者 static；
* 抽象类可以有构造方法，接口不能有；
* 实现的话，抽象类依靠子类使用 extends 继承，接口则用 implements；
* 一个类最多只能继承一个类，但是可以实现多接口；
* 抽象类被继承时体现的是 is-a 关系，接口被实现时体现的是 can-do 关系。

2、成员变量和方法的区别

成员变量是属性，体现了对象有什么特性，成员方法是行为，体现了对象能干什么。

3、内部类

内部类有四种：成员内部类、静态内部类、方法内部类以及匿名内部类
[Java基础复习(四、三大特性) - 内部类](https://blog.csdn.net/kirito_lewis/article/details/105953550#innerclass)

4、基本数据类型，拆箱装箱

七种，byte、short、int、long、float、double、char。
拆箱装箱是因为他们的包装类型，可以运行下面代码：
```
int i = 3;
Integer j = i;
```
这是因为编译器自动将这段代码变成了调用`Integer.valueOf()`方法。还有`intValue()`方法的使用。

5、java的同步和并发

同步就是单线程操作，没啥好说的。
并发就是多线程操作，通过线程来完成多任务的操作。
创建线程的三种方式：1、集成`Thread`类；2、实现`Runnable`接口；3、实现`Callable`接口。
优缺点：
(1)、采用实现Runnable、Callable接口的方式创建多线程时，
优势是：
线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。
在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
劣势是：
编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。
(2)、使用继承Thread类的方式创建多线程时，
优势是：
编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。
劣势是：
线程类已经继承了Thread类，所以不能再继承其他父类。
(3)、Runnable和Callable的区别
[1] Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。
[2] Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。
[3] call方法可以抛出异常，run方法不可以。
[4] 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。

6、HashMap的底层实现和扩容机制等

底层实现，bucket + linkedlist/红黑树
扩容机制：
当`size > threshold (该字段记录下一次扩容的大小，capacity * load factor)`时，调用 `resize()`方法，Map 容量乘以 2，以保证容量是 2 的幂次，然后将原来的节点放到新的 bucket 中。

7、GC 垃圾回收机制

如果是问垃圾回收策略的话，有以下三个：
(1)复制回收算法
此种方法通过依次扫描区域所有的可达对象，然后将其复制到另外一片区域保存起来，再将其现在正在使用的区域内存全部清空，此方法的优点在于方便快捷，只需要便利出所有的可达对象即可，而且不会出现碎片化内存。但是缺点也很明显，复制对象需要计算成本，此外需要准备一个额外相同Eden区域大小的内存空间，也是一笔巨大的开销。
(2)标记清除法
这种方法首先遍历整个区域中的对象，然后标记所有的可达对象，再将所有内存中未被标记的对象全部清除。主要缺点在于会产生大量的碎片内存。
(3)标记整理法
这种方法集上面两种算法的优点于一身，首先遍历整个空间对可达对象进行标记，然后再将所有可达对象整理到一起去，最后清除掉不可达的对象，达到GC回收清理内存的目的。（这个跟复制回收算法有区别？？？）

8、Java 编译后的字节码文件结构是怎样的？

（这谁记得住啊。。。）首先是 4 个字节的魔数(用于查看文件是否能运行，因为后缀名可以随便改)。2 个字节的次版本号，2 个字节的主版本号（版本号用于判别虚拟机是否可以运行当前版本，可以向下兼容）。2 个字节常量池计数值，（常量计数值 - 1）* （对应类型的大小）个字节的常量池大小，大小跟常量类型有关。然后是 2 个字节的访问标志（是类还是接口，是不是 public 类， 是不是 abstract 类型，有没有被声明成 final 等等）。2 个字节的类索引（确定全限定名）和 2 个字节的父类索引（父类的全限定名）。2 个字节的接口计数值，（接口数 * 2）个字节的接口。2个字节的字段计数值，（字段计数值 * 对应类型的大小）个字节的字段。2 个字节的方法计数值，（方法计数值 * 对应方法的大小）个字节的方法。

9、算法：每k个反转链表，leetcode原题。

这题在 LeetCode 中算 hard 的啊。。。
```
	public ListNode reverseKGroup(ListNode head, int k) {
	    ListNode dummy = new ListNode(0);
	    dummy.next = head;

	    ListNode pre = dummy;
	    ListNode end = dummy;

	    while (end.next != null) {
	        for (int i = 0; i < k && end != null; i++) end = end.next;
	        if (end == null) break;
	        ListNode start = pre.next;
	        ListNode next = end.next;
	        end.next = null;
	        pre.next = reverse(start);
	        start.next = next;
	        pre = start;

	        end = pre;
	    }
	    return dummy.next;
	    }

	    private ListNode reverse(ListNode head) {
	    ListNode pre = null;
	    ListNode curr = head;
	    while (curr != null) {
	        ListNode next = curr.next;
	        curr.next = pre;
	        pre = curr;
	        curr = next;
	    }
	    return pre;
	}
```

**二面**：

1、计算机网络组成原理

OSI模型和TCP/IP模型以及两者的综合五层模型

2、计网

a、五层结构有哪几层？哪一层实现最麻烦？

物理层、数据链路层、网络层、传输层、应用层。应用层实现最麻烦，因为不同应用的协议

b、TCP 是干什么的？为什么有了 TCP 还需要 IP 等协议？TCP 可靠传输如何实现？三次握手?为什么需要三次？

TCP是传输层的协议，用于端到端的报文段的可靠传输。
IP协议是网络层的，用于网际互联，注重的层次不一样，因此需要IP这些协议。
通过三次握手构建稳定链接。三次握手四次拜拜。如节点A和节点B之间传输数据，三次握手分别是：1、节点A发送到节点B，表示节点A发送功能没问题；节点B收到数据后将结果发送到节点A，表示节点B发送功能和接收功能都没问题；节点A收到数据后将结果发送给节点B表示自己接收功能没问题

c、DNS 解析的过程，为什么目的是获得 IP 还要用 URL？直接用 IP 不好吗？根服务器在哪里？

(1)先找浏览器缓存中有没有，有则返回没有则下一步；
(2)再找系统缓存（Host文件）中有没有，有则返回没有则下一步；
(3)在路由器缓存中查找，有则返回没有则下一步；
(4)到互联网服务提供商DNS缓存中查找（电信、移动），有则返回没有则下一步；
(5)到根域名服务器的区域文件记录中查找，有则返回没有则将其管辖范围内顶级域名服务器IP告诉本地DNS服务器；
(6)顶级域名服务器查看区域文件记录，有则返回没有则将其管辖范围内主域名服务器的IP告诉本地DNS服务器；
(7)主域名服务器查找自己缓存，有则返回没有则进入下一级域名服务器查找，直到找到正确记录；
(8)本地域名服务器把返回的结果保存到缓存，并返回客户端。
之所以需要URL不用IP是因为IP不好记，URL比较好记。
根服务器分布在全球，一共为13台原有根+25台v6辅助根。中国有4台，一台主根和三台辅根。

d、HTTP 和 HTTPS，HTTPS 如何加密？

HTTP是超文本传输协议，用于Web浏览器和服务器之间传递消息，以明文方式交换数据，因此不安全。
HTTPS是安全套接字层超文本传输协议，在HTTP的基础上添加了SSL协议，依靠证书来验证服务器的身份，并提供了通信加密。

3、OS

a、磁盘空间空闲管理

[Linux磁盘空闲空间调度管理](https://blog.csdn.net/roger_ranger/article/details/77689709)

4、数据库

a、数据库索引是什么？为什么选择 B+ 树？

索引就是为了避免全表查找，利用特定列形成B+树从而加快搜索的速度。
选用B+树是因为稳定且好用。不用Hash数组是因为在分组、排序等操作时，复杂度会退化成O(n)，而B+树还是O(logn)。不用二叉查找树是因为B+树的范围查找比二叉查找树优秀，不需要中序回溯，并且改进后查询全部数据时不需要中序遍历而是直接用链表。
总的来说就是：
（1）适合磁盘存储，能够充分利用局部性原理，磁盘预读；
（2）树高度较小，能够存储大量数据（相对于二叉树而言）；
（3）索引本身占用的内存很小；
（4）能够很好的支持单点查询，范围查询，有序性查询。

5、算法：

a、给一个整数数组，找右边元素减左边元素的最大差值

LeetCode 股票题解：
```
	public int maxProfit(int[] prices) {
		int[] values = new int[prices.length-1];
		// 将每天的价格变成每天相比前一天的变化量
		for(int i=0;i<prices.length-1;i++) {
			values[i] = prices[i+1]-prices[i];
		}
		// 求最大子序列和
		int res = values[0];
		for(int i=1;i<values.length;i++) {
			values[i] += Math.max(values[i-1], 0);
			res = Math.max(res, values[i]);
		}
		return res>0?res:0;
    }
```
b、旋转数组
```
	public void rotate(int[] nums, int k) {
		int[] a = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            a[(i + k) % nums.length] = nums[i];
        }
        for (int i = 0; i < nums.length; i++) {
            nums[i] = a[i];
        }
    }
```

**三面**

1、关于Linux和Android的了解？？？

2、代码环节

a、线程内部修改外部变量，外部变量用static和voaltile修饰时情况是怎么样的。去除这些关键字，如何实现变量一经修改，外部打印语句就可以马上打印新的值。

b、算法题：二进制反转

c、二叉树的前序遍历的Iterator

3、职业规划
（这个感觉讲的不是很清楚）

#### 5月22日总结
[阿里Java后端1-5面](https://www.nowcoder.com/discuss/429993?channel=1000&source_id=home_feed)

**一面**：

1、 触发新生代GC，如果存活对象总量大于survivor区容量，咋办

把无法容纳的对象直接放到老年代里（《Java虚拟机》-- 3.6.5 空间分配担保）

2、 如果任务很多，线程池的阻塞队列会撑爆内存的哪个区域

堆吧。。。

3、 栈在堆上吗

不是，栈的话独立分配了一个内存

4、 GC root有哪些

有以下几种：
Class、Thread、Stack Local、JNI Local、JNI Global、Monitor Used、Held By JVM
在Java语言里，可作为GC Roots对象的包括如下几种：
* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中的类静态属性引用的对象
* 方法区中的常量引用的对象
* 本地方法栈中JNI引用的对象

5、 实例变量可以是GC root吗

可以的吧，按照上面的说法来看

6、 了解哪些GC算法，介绍一下

三种吧：
（1）准备一个区域，将对象复制过去然后清空。这个方法可以产生空间较大的连续内存空间
（2）将回收的对象当场回收，这样会产生很多碎片空间
（3）上面两者的结合

7、 给个场景，问怎么设置JVM参数

= =、不会设

8、 问了很多SQL调优，各种语句能不能命中索引，能命中哪些，怎么优化

这个看这说把，首先<>和!=运算是肯定不走索引的，or的话要看前后两个条件都需要有索引才走索引。

9、 MySQL的一张表里有三个字段ABC，A的种类有1000种，B有1W种，C有10W种，ABC的联合索引怎么设置，怎么使用

key index_C_B_A on test(c,b,a)
使用的话尽量按照上面这个顺序

10、 Mybatis # 和 $ 的区别

不造

11、 Mybatis接口里的方法和XML里的SQL名可以不一样吗，不一样怎么办

不造

12、 Mybatis是如何完成SQL和接口里的方法的映射的（我回答了怎么配置），那你知道它是怎么实现的吗

实际上应该还是拦截器和动态代理的方法。。。具体没研究过

13、 介绍下Spring的 IOC和AOP

IOC就是控制反转，通过XML配置信息或者注解实现容器的自动管理。比如说我们有一个service，在用的时候我们可以通过@Service将其装配到容器仓库，等到用的时候直接@Autowired就可以自动装载了，而不需要 new xxx 这样的做法。
AOP则是面向切面编程的缩写，Spring的AOP是利用动态代理技术实现AOP原理的。Spring中用了两种技术，一种是JDK的Proxy包，为接口动态生成代理类；一种是CGlib动态代理，在目标类加载后动态生成目标类的子类并把切面逻辑加进去

14、 服务器给客户端发送IO流的过程

（1）服务器建立socket，等待客户机连接
（2）客户机连接
（3）服务端write，客户机read

15、 IO和NIO了解多少

NIO是jdk1.4以后引入的，和IO的作用和目的相同，但是实现方式不同。
（1）IO是面向流的，NIO是面向缓冲区的。也就是说IO我们需要自己建立缓存区，而NIO用的时候就需要用ByteBuffer来做
（2）IO是阻塞的，NIO是非阻塞的。IO会等到所有要收到的数据全部收到后才能再去做其他事情，NIO允许一条线程从channel中读取数据，通过返回值来判断buffer中是否有数据，如果没有数据，NIO不会阻塞
（3）NIO允许一条线程去监控多个channels的输入
总结：
NIO允许你使用一个单独的线程或几个线程管理很多个channels，代价是处理逻辑更加复杂
如果连接比较多且每个连接发送数据比较少，用NIO比较合适，否则用IO更好

16、 线程都有哪些状态，怎么转换的

new、runnable、running、blocked、dead
初始化进入new状态，调用了start()方法后进入runnable状态，获得CPU后进入running状态，因为某些原因放弃CPU进入blocked状态，当sleep()结束或者IO处理完毕或者被唤醒进入runnble状态。当方法结束或者因为异常退出，则进入dead状态，不可复生

17、 Notify和notifyAll的区别

前者随机唤醒一个该锁的线程，后者是全部唤醒

18、 介绍线程池，不同线程池区别在哪，你平时怎么使用线程池的

线程池就是不需要代码自己创建线程，而是直接获取线程池中的线程，用完再还回去。相比手工创建和运行，能够降低线程创建和销毁的开销、提高响应速度、提高线程的可管理性。当你提交一个任务时，线程池首先会去看核心线程数是否达到上限，如果没有那就新建一个核心线程用来执行任务，否则去检查阻塞队列，如果阻塞队列未满，则加入阻塞队列，否则检查总线程数是否达到阈值，如果没有达到阈值，就建立一个非核心线程用来执行任务，否则执行线程池饱和策略。
核心线程数由 corePoolSize 参数决定，阻塞队列必须实现 BlockingQueue 接口，非核心线程达到存活的最长时间就销毁，饱和策略有：抛出异常（默认）、抛弃任务、抛弃最旧（下一个要运行）的任务、在主线程中执行任务。
不同线程池区别在于核心线程数是否固定、阻塞队列的实现（如ArrayBlockingQueue、LinkedBlockedQueue、PriorityBlockingQueue、DelayQueue、SynchronousQueue）、非核心线程数的最长存活时间等等参数的限定。

19、 MySQL索引的数据结构

实际上就是列（或者说属性）的B+树

20、 B+树了解多少

中间节点是空的，只有叶子节点存放数据。一个叶子节点存放多个数据。中心节点放子节点的最大或者最小值，只当索引。叶子节点还是一个链表。

21、 Cookie和SessionId说一下

由于 Http 是一种无状态的协议，为了识别连接的发起者是谁，需要应用层自己去实现，因此诞生了 Session 和 cookie。Session 是保存在服务器端，Cookie 保存在客户端。

22、 锁是怎么实现的

[AQS](https://www.cnblogs.com/fsmly/p/11274572.html)

23、 Synchronized同步块和synchronized方法，分别锁的是什么

同步块可以自己指定锁对象，synchronied 方法锁 this.class

24、 单例模式，饿汉和懒汉分别存在的问题

懒汉，线程不安全，没有加锁；
饿汉，浪费内存

25、 Volatile是怎么实现可见性的

[volatile](https://www.cnblogs.com/dolphin0520/p/3920373.html)
其实就是产生的汇编代码会导出一个lock前缀指令，这个指令会使当前处理器缓存的数据写回系统内存，并使其他缓存失效（使高速缓存中的值失效，而不是使CPU寄存器中的值失效！！！缓存一致性协议只针对缓存！）

26、 介绍下JMM

Java内存模型

27、 Happen before了解吗

八条 happen-before 原则：
* 程序次序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作；
* 锁定规则：对一个锁的解锁，happens-before于随后对这个锁的加锁；
* volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读；
* 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C；
* start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作；
* Join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回；
* 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生；
* 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。

28、 A happen before B，意味着A一定在B之前执行吗

不一定，比如 `int a=0; int b=0;`这两条没有关联的命令可以重排序

29、 你做过的最难的项目中，最难的任务是什么，怎么解决的

**二面**：

1、 看过哪些源码？

= =、包装类型、HashMap、AQS、ReentrantLock等等

2、 Java都有哪些map，分别怎么实现的，具体讲

HashMap -> bucket + LinkedList/红黑树
LinkedHashMap -> bucket + LinkedList/红黑树 + 双向链表
ConcurrentHashMap -> HashMap + CAS + Synchronized
TreeMap -> 红黑树

3、 除了LinkedHashMap，你还知道哪些有序map

???LinkedHashMap 不是有序的啊！！！TreeMap 有序

4、 ConcurrentHashMap讲一讲

就是 HashMap + CAS + Synchronized 呗，每一个bucket 作为一个锁，在 putVal() 里面使用 synchronized 将该 bucket 锁住，并使用 CAS 去赋值

5、 为什么要有线程池

避免手动创建和销毁，这样太浪费资源了。节省时间，直接拿比创建更快。提高线程的可管理性

6、 线程池有哪几类？有什么区别？有哪些参数？拒绝策略有哪些

（1） FixedThreadPool -> 核心线程数 = 最大线程数，即全是核心线程没有非核心线程，阻塞队列是 LinkedBlockingQueue
（2）SingleThreadPool -> 只有一个核心线程，阻塞队列是 LinkedBlockingQueue，适用于多个线程线性执行的场景
（3）CachedThreadPool -> 没有核心线程，只有最大个非核心线程
参数有：核心线程数、最大线程数（核心+非核心）、最大存活时间、TimeUnit、阻塞队列、ThreadFactory 和一个 RejectedExecutionHandler
拒绝策略：
* 抛出异常
* 直接丢弃
* 抛弃最旧的
* 交给主线程执行

7、 阻塞队列都有哪几种，有什么区别

**这边博客还没写完！！！**

8、 Java的反射怎么理解

反射就是获取类的 class 文件，就知道了这个类的属性和方法，然后调用

9、 Spring的IOC和AOP怎么理解

IOC 控制反转，实现容器的自动管理，不需要我们自己去 new
AOP 切面，通过动态代理和反射去实现面向切面编程

10、 Spring项目启动的时候会加载哪些资源，顺序是怎么样的

**这个没看呢**

11、 浏览器输入一个URL，会发生什么，整个过程说一下

这是要问我 DNS 的意思吧。。
（1）首先查看浏览器缓存，找这个 URL 对应的 IP
（2）再找系统文件（WINDOWS c盘下面有个 host 文件），找这个 URL 对应的 IP
（3）再找路由器中缓存
（4）去找本地 DNS 服务器
（5）本地 DNS 服务器去找根域名服务器，没找到的话返回主域名服务器 IP
（6）本地 DNS服务器去找主域名服务器中，没找到的话返回下一级域名服务器
（7）本地 DNS服务器 再去找下一级
（8）找到后本地域名服务器保存到缓存，返回客户端


12、 Http讲一讲，请求有哪些内容，响应有哪些内容

请求报文：
* 请求行：方法 + （空格）+ URL + （空格） + 版本 + （CRLF，回车换行）
* 首部行：n * { 首部字段名 +（封号）+（空格）+ 值 + CRLF }
* CRLF
* 实体主体

响应报文：
* 状态行： 版本 + （空格）+ 状态码 + （空格） + 短语 + （CRLF，回车换行）
* 首部行：n * { 首部字段名 +（封号）+（空格）+ 值 + CRLF }
* CRLF
* 实体主体

13、 你笔试分好高，平时刷过很多题吗？怎么刷的？

呵呵，我没面！！！orz。。。。

