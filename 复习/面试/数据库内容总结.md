## 数据库内容总结

在很多篇面经中都看到了数据库相关知识点，很多内容一知半解，看到别人能讲到 MVCC 很是羡慕，于是在此整理一下常问的问题，给自己扫一下盲。

### 一、索引相关
#### 1.什么是聚簇索引和非聚簇索引？

首先，聚簇索引和非聚簇索引指的是数据的物理存储方式，他们的区别在于根据索引查到的是直接的数据还是主键值，跟索引的数据结构、是否是 B+ 树没有关系。

##### 聚簇索引

聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。
InnoDB 通过主键聚集数据，如果没有定义主键，InnoDB 会选择非空的唯一索引代替。如果没有这样的索引，InnoDB 会隐式的定义一个主键来作为聚簇索引。
聚簇索引的优缺点
优点：
* (1) 数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
* (2) 聚簇索引对于主键的排序查找和范围查找速度非常快
缺点：
* (1) 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键
* (2) 更新主键的代价很高，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义主键为不可更新。
* (3) 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。

##### 非聚簇索引

在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的 Page Directory 找到数据行。
InnoDB 辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外，还包含了相应行数据的聚簇索引键。
辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在 InnoDB 中有时也称辅助索引为二级索引。



#### 2.聚簇索引和非聚簇索引用在什么地方？

一般我们提到聚簇索引和非聚簇索引，都是在 InnoDB 和 MyISAM 的比较中。 InnoDB 使用聚簇索引构建了主键的 B+ 树，其他辅助索引叶子节点找到的都是主键的值，然后通过主键去寻找聚簇索引的叶子节点，拿到具体的行数据。而 MyISAM 则都是非聚簇索引，即使是二级索引叶子节点存储的也是地址，跟利用主键构造的索引是一样的。

如下图所示，可以看到在 InnoDB 中，所有辅助键索引在查找完成之后得到的都是主键的值，还需要再次通过主键索引去查找具体的行数据（即覆盖索引，一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取，减少了 IO 操作）；而在 MyISAM 中，辅助键索引能直接找到具体的行数据的地址，这就避免了再一次的主键索引，因此光是从这方面来说，MyISAM 的查询效率应该是比 InnoDB 要高的，但是加上 IO 操作的时间就不好说了。

![聚簇索引和聚簇索引](/Users/y1271752959m/Documents/WorkHardAndFindJob/复习/面试/images/聚簇索引和非局促索引.png)



#### 3.主键索引和辅助键索引、一级索引和二级索引等概念的区别

**聚簇索引和非聚簇索引**
聚簇索引和非聚簇索引是从物理存储方面进行划分的。
聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致，聚集索引表记录的排列顺序与索引的排列顺序一致，优点是查询速度快，因为一旦
具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后。
聚集索引的缺点是对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排，
降低了执行速度。非聚集索引指定了表中记录的逻辑顺序，但记录的物理顺序和索引的顺序不一致，聚集索引和非聚集索引都采用了B+树的结构，但非聚集索引的叶子层并不与实际的存储空间直接挂钩。

**主键索引和辅助键索引**
主键索引对主键构建的索引，是在我们创建表激活后由系统自动创建的。辅助键索引是对非主键的列构建的索引，由我们自己创建。

**一级索引和二级索引**
查了一圈没有看到一级索引的字眼，所以一级索引这个称呼应该是不 正式的，我们所谓的一级索引其实就是聚簇索引（聚簇索引必定是由主键构成的），因为其他索引都得重新走一遍聚簇索引才能拿到值。二级索引是和一级索引相比较的概念，是辅助键索引有时候的称呼（存在聚簇索引就可以称呼辅助键索引为二级索引），称呼为二级索引是因为在走完辅助键索引之后，还得再走一遍聚簇索引才能取到值，所以辅助键索引地位较低。

**单列索引和联合索引**
单列索引就是对单独一个列建立的索引。联合索引是对多个字段同时建立的索引，具体看[联合索引的详情](#union_index)

**一般(normal)索引和唯一性(unique)索引**
一般索引就是普通索引，这没什么好讲的，而唯一性索引则是在普通索引的基础上加上了索引列的唯一性的约束（允许有空值），如果是联合索引，那么索引列的组合必须唯一。比如说，一般索引举个例子，人名，国家允许多个相同人名的人出现；唯一性索引，举个例子，身份证，不允许重复，或者说你们班级里有两个同名的人，一男一女，那么（名字 + 性别）也能作为唯一性索引，反正就是必须唯一。

**B+ 树索引、哈希（hash）索引、全文（full-text）索引、空间数据（R-tree）索引**
这是从索引的逻辑结构进行划分的。[参考博客](https://www.cnblogs.com/JasonCeng/p/12044109.html)
**B+ 树索引**是将列进行树化，变成一颗 B+ 树。InnoDB 中的聚簇索引就是 B+ 树。
**哈希索引**（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，并在哈希表中保存指向每个数据行的指针。

![哈希索引图解](/Users/y1271752959m/Documents/WorkHardAndFindJob/复习/面试/images/哈希索引图解.png)

**全文索引**主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。
**R-tree 索引**MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无须前缀索引。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。必须使用MySQL的GIS相关函数如MBRCONTAINS()等来维护数据。MySQL的GIS支持并不完善，所以大部分人都不会使用这个特性。



#### <a id="union_index">4.联合索引的详情</a>

在很多篇面经中都讲到了联合索引的知识，这边我们再梳理一下。
对于两个或两个以上列的索引称为复合索引。在创建了联合索引之后，我们进行多个字段的查询时可以只用索引中的一部分，但只能是最左侧部分，例如索引是 index(a,b,c) ，那么该索引可以支持 a | a,b | a,b,c 三种组合进行查找，但不支持 b,c 进行查找（最左原则），支持 a,c 但是实际上只用到了 a 索引。
联合索引常常和[优化索引](#index_optimize)一起问到。



#### 5.索引的底层结构

前面我们讲了这些个索引的作用和区别，现在我们来讲讲索引的底层结构，为什么索引能优化查询。
如果没有索引，我们查询数据的时候，没有任何工具可以依靠，那么只能通过**全表遍历**来查询。
对于有序的数据来说，可以对全表遍历进行优化，通过二分查找的方式进行查询。但是这样的查询方法依旧不够好，只能用于有序数据，其他的就不行。
**哈希索引**通过计算键的 hash 值，然后在相应的物理空间存储该行数据的地址。哈希索引能以 O(1) 时间进行查找，但是失去了有序性：
* 无法用于排序与分组；
* 只支持精确查找，无法用于部分查找和范围查找。
InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

**B+ 树索引**是通过将键构成一棵 B+ 树进行查找的。关于 B+ 树的内容可以自己搜索。InnoDB 的主键索引就是 B+ 树索引。InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

**全文索引**MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。



#### <a id="index_optimize">6.如何优化索引</a>

* 尽量选择惟一性索引；
* 为经常需要排序、分组和联合操作的字段建立索引；
* 为常作为查询条件的字段建立索引；
* 限制索引的数目，索引越多，更新和插入的效率越低；
* 尽量使用数据量少的索引；
* 组合索引中的尽量把能过滤掉更多数据的字段放在前面，把最经常使用的字段放在前面（最左原则）；
* 尽量使用前缀来索引，针对长文本，TEXT等类型；
* 删除不再使用或者很少使用的索引；
* 数据是动态变化中的，索引的使用也需要根据数据的变化而变化。



---------------



### 锁相关
#### 1.什么是锁？MySQL 中提供了几类锁？

锁是多用户竞争的一种临界资源，是实现数据库并发控制的重要手段，可以保证数据库在多人同时操作时能够正常运行。MySQL 提供了全局锁、行级锁、表级锁。其中 InnoDB 支持表级锁和行级锁，MyISAM 只支持表级锁。



#### 2.锁的划分

* 按照锁的粒度划分：行锁、表锁、页级索、全局锁
* 按照锁的使用方式划分：共享锁、互斥锁（悲观锁的一种实现）
* 还有两种思想上的锁：悲观锁、乐观锁
* 在读写锁的基础上引入的意向锁，实现锁的细粒度化
* InnoDB中有几种行级锁类型：Record Lock、Gap Lock、Next-key Lock
	* Record Lock：在索引记录上加锁
	* Gap Lock：间隙锁
	* Next-key Lock：Record Lock+Gap Lock
	

(1) 行锁、表锁、全局锁：行锁是对行数据进行加锁，表锁是对整张表进行加锁，页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁，一次锁定相邻的一组记录，而全局锁是对整个数据库进行加锁。

(2) 共享锁、互斥锁:互斥锁（Exclusive），简写为 X 锁，又称写锁。共享锁（Shared），简写为 S 锁，又称读锁。
* 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
* 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。


(3) 悲观锁、乐观锁
锁|概述|使用场景|样例
---|---|---|---
**悲观锁**|悲观锁对数据被外界修改持保守态度（悲观），因此在整个数据处理过程中，将数据出于锁定状态，而别的任务出于被阻塞的状态；|写多读少，保证写操作时的数据安全|1、JVM中的synchronized和Lock；2、分布式环境基于数据库行锁、页锁、表锁、共享锁（读锁）、排它锁（写锁）；3、基于zookeeper、Redis 的分布式锁
**乐观锁**|乐观锁认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的重提与否进行检测，如果发现冲突了，程序自动去重试（实现通常用“版本号”）|读多写少，提高系统吞吐|1、JDK并发包中的原子类；2、数据库乐观锁、缓存乐观锁

(4) 意向锁
使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。
在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。
意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：
* 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
* 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。
下图是意向锁之间的兼容关系

![意向锁兼容关系](/Users/y1271752959m/Documents/WorkHardAndFindJob/复习/面试/images/意向锁兼容关系.png)

解释如下：
* 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
* 这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）

(5) Record Lock、Gap Lock、Next-key Lock



#### 什么是死锁？

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的过程称为死锁。



#### 如何处理死锁

对待死锁常见的两种策略：
* 通过 innodblockwait_timeout 来设置超时时间，一直等待直到超时；
* 发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其它事务继续执行。



#### 如何判断死锁

(1) 超时法
如果某个事物的等待时间超过指定时限，则判定为出现死锁

(2) 等待图法
等待图法指的是如果事务等待图中出现了回路，则判断出现了死锁



#### 如何查看死锁？

* 使用命令 show engine innodb status 查看最近的一次死锁。
* InnoDB Lock Monitor 打开锁监控，每 15s 输出一次日志。使用完毕后建议关闭，否则会影响数据库性能。



#### 如何避免死锁？



--------------



### 事务相关
#### 1.什么是事务

事务是**一系列的数据库操作，是数据库应用的基本单位**。MySQL 事务主要用于处理操作量大，复杂度高的数据。

#### 2.事务的特性

在 MySQL 中只有 InnDB 引擎支持事务，它的四个特性如下：
* 原子性（Atomic）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位；
* 一致性（Consistency）：事务的执行使得数据库从一种正确状态转化为另一种正确状态，事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到；
* 隔离性（Isolation）：在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务，同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账；
* 持久性（Durability）：事务提交后，其结果永久保存在数据库中。

#### 3.事务的并发问题

1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
**幻读和不可重复读的区别？**
* 不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）。
* 幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）。

#### 4.MySQL 中有几种事务隔离级别

四种，如下表
事务隔离级别|脏读|不可重复读|幻读
---|---|---
读未提交（read-uncommitted）|是|是|是
不可重复度（read-commited）|否|是|是
可重复读（repeatable-read）|否|否|是
串行化（serializable）|否|否|否

mysql 默认的事务隔离级别为 repeatable-read

#### 5.MVCC 是什么？

MVCC 是多版本并发控制（Multi-Version Concurrency Control）的简称，是用来解决事务中排他锁的使用导致读操作等待的。在四种隔离级别中，不可重复度和可重复读是使用了 MVCC 的，而串行化是使用了表级锁，读未提交好像什么都没实现。



--------------

### 一些问题
1、MyISAM 实现了表级锁，为什么说它没有事务功能？
2、

