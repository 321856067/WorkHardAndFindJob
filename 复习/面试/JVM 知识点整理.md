
# 一. Java 内存模型
Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK. 1.8 和之前的版本略有不同，下面会介绍到。

![图片](https://uploader.shimo.im/f/AYz2LzaDzdvd299Y.png!thumbnail)

![图片](https://uploader.shimo.im/f/ZNgeg4eFk6oynDCD.png!thumbnail)

![图片](https://uploader.shimo.im/f/AxX5YyBeGEQjKz4U.png!thumbnail)

![图片](https://uploader.shimo.im/f/0KNMttlcYUMn8fMr.png!thumbnail)

## 1. 程序计数器

程序计数器（Program Counter Register）是一块**较小的内存空间**，它可以看作是当前线程所执行的字节码的**行号指示器**。在Java虚拟机的概念模型里，**字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令**，它是程序控制流的**指示器，分支、循环、跳转、异常处理、线程恢复**等基础功能都需要依赖这个计数器来完成。

由于Java虚拟机的**多线程是通过线程轮流切换**、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，**每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存**。

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中**没有规定任何OutOfMemoryError情况的区域。**

## 2. Java虚拟机栈

与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每个方法被执行的时候，Java虚拟机都会同步创建一个**栈帧**（Stack Frame）用于**存储局部变量表、操作数栈、动态连接、方法出口**等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

![图片](https://uploader.shimo.im/f/HzoubRHIGogRJegg.png!thumbnail)

**Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。**

* StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
* OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。

### （1）局部变量表

**局部变量表(Local Variable Table)**是一组变量值存储空间，用于存放方法**参数**和方法内**定义**的**局部变量**。局部变量表的容量以**变量槽**(Variable Slot)为最小单位，Java虚拟机规范并没有定义一个槽所应该占用内存空间的大小，但是规定了一个槽应该可以存放一个32位以内的数据类型。

>在Java程序编译为Class文件时,就在方法的Code属性中的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。(最大Slot数量)
* 一个局部变量可以保存一个类型为boolean、byte、char、short、int、float、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。
* 局部变量表所需的内存空间在**编译期间**完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小
* 虚拟机通过索引定位的方法查找相应的局部变量，索引的范围是从 0~局部变量表最大容量。如果 Slot 是32位的，则遇到一个**64 位数据类型的变量(如 long 或 double 型)**，则会连续使用两个连续的 Slot 来存储。

### （2）操作数栈

**操作数栈(Operand Stack)**也常称为操作栈，它是一个后入先出栈(LIFO)。同局部变量表一样，**操作数栈的最大深度也在编译的时候写入到方法的 Code 属性的 max_stacks 数据项中。**

操作数栈的每一个元素可以是任意 Java 数据类型，32 位的数据类型占一个栈容量，64 位的数据类型占 2 个栈容量,且在方法执行的任意时刻，操作数栈的深度都不会超过 max_stacks 中设置的最大值。

当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。

![图片](https://uploader.shimo.im/f/crzWX2d1gCJ9y1gw.png!thumbnail)

![图片](https://uploader.shimo.im/f/QMwQuDC3U8Io7MXr.png!thumbnail)

### （3）动态连接

在一个class文件中，一个方法要调用其他方法，需要将这些方法的**符号引用转化为其在内存地址中的直接引用**，而**符号引用**存在于方法区中的**运行时常量池**。

Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的**动态连接(Dynamic Linking)**。

这些符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为**静态解析**。另一部分将在每次运行期间**转化为直接引用**，这类转化称为**动态连接**。

### （4）方法返回地址

**两种退出情况**

* **正常退出：**是指方法正常完成并退出，没有抛出任何异常(包括Java虚拟机异常以及执行时通过throw语句显示抛出的异常)。如果当前方法正常完成，则根据当前方法返回字节码指令，这时有可能会有返回值传递给方法调用者(调用它的方法)，或者无返回值。具体是否有返回值以及返回值的数据类型将根据该方法返回的字节码指令确定
* **异常退出：**是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。无论方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态。
* **退出三种方式：**
  * 返回值压入上层调用栈帧
  * 异常信息抛给能够处理的栈帧
  * PC计数器指向方法调用后的下一条指令

### （5)  附加信息

虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧之中，例如和调试相关的信息，这部分信息完全取决于不同的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其他附加信息一起归为一类，称为栈帧信息。

## 3. 本地方法栈

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如 HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出`StackOverflowError`和`OutOfMemoryError`异常。

## 4. 堆区

#### (1) 简述

对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是**存放对象实例**，**Java世界里“几乎”所有的对象实例都在这里分配内存**

Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存**

#### (2) 分类

**注意：**

**堆的内存可以调整**

![图片](https://uploader.shimo.im/f/eFMjHWAyEiH5x8gX.png!thumbnail)

在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：

* 新生代内存(Young Generation)
* 老生代(Old Generation)
* 永生代(Permanent Generation)

![图片](https://uploader.shimo.im/f/uyErUhBaixWE5xkw.png!thumbnail)

JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。

![图片](https://uploader.shimo.im/f/jkq9UYTstCmHcpFa.png!thumbnail)

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置

#### (3) 对象分配与简要流程图

![图片](https://uploader.shimo.im/f/CnUIk4lwOi4IwKdI.png!thumbnail)

#### (4) OutOfMemoryError

堆这里最容易出现的就是 **OutOfMemoryError** 错误，并且出现这种错误之后的表现形式还会有几种，比如：

* **OutOfMemoryError**: **GC Overhead Limit Exceeded **： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
* **java.lang.OutOfMemoryError:** **Java heap space **:假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发java.lang.OutOfMemoryError: Java heap space 错误。(和本机物理内存无关，和你配置的内存大小有关！)
## 5.方法区

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被**虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。

### (1) 方法区和永久代的关系

>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。
### (2) 常用参数

JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小

```plain
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
```
相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。
JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。

下面是一些常用参数：

```plain
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```
与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建**，虚拟机会耗尽所有可用的系统内存。**
### (3) 为什么要将永久代（PermGen）替换为元空间（MetaSpace）

* 整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
>当你元空间溢出时会得到如下错误： java.lang.OutOfMemoryError: MetaSpace

你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

* 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。
* 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。
>考虑到HotSpot未来的发展，在JDK 6的时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了[插图]，到了**JDK 7的HotSpot**，已经把原本放在永久代的**字符串常量池（放到堆中了）**、静态变量等移出，而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta-space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。

**JDK8中将永久代的字符串常量移到堆中，其他内容包括类元信息、字段、静态属性、方法、常量都移动到元空间。**

### (4) 常量池随永久代的变化

![图片](https://uploader.shimo.im/f/cqfiC3qaQCUMn47J.png!thumbnail)

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中

运行时常量池相对于Class文件常量池的另外一个重要特征是**具备动态性**，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中

**注意JDK8后将字符串常量池在堆中了，而运行时常量池应该在元空间中，网上各种说法乱七八糟**

## 6.直接内存（不是运行时数据区的东西）

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。**

JDK1.4 中新加入的 **NIO(New Input/Output) **类，引入了一种基于**通道**（Channel） 与**缓存区**（Buffer） 的 I/O 方式，它可以直接使用 Native 函数库直接分配**堆外内存**，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据。**

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。