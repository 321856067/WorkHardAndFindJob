## 887：鸡蛋掉落
**题目**：
你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。
每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。
你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。
每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。
你的目标是确切地知道 F 的值是多少。
无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

**示例1**：
>输入：K = 1, N = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。

**示例2**：
输入：K = 2, N = 6
输出：3

**示例3**：
输入：K = 3, N = 14
输出：4

**提示**：
* 1 <= K <= 100
* 1 <= N <= 10000

**思路**：
一开始以为是二分法，等到剩下一枚鸡蛋的时候再一层层往上，但是显然这样的方法期望值相差太大。而且本题的目的并不是这个，而是动态规划。。。所以说这道题目真的很难，连题目理解都很难。
```
	public static int superEggDrop(int K, int N) {
    	int[][] dp = new int[K+1][N+1];
    	for(int i=1;i<=N;i++) {
    		dp[1][i] = i;
    	}
    	for(int i=1;i<=K;i++) {
    		dp[i][1] = 1;
    	}
    	for(int i=2;i<=K;i++) {
    		for(int j=2;j<=N;j++) {
    			int min = Integer.MAX_VALUE;
    			for(int k=2;k<=j;k++) {
    				min = Math.min(min, Math.max(dp[i-1][k-1], dp[i][j-k]) + 1);
    				dp[i][j] = min;
    			}
    		}
    	}
    	return dp[K][N];
    }
```
方法超时，所以说还得优化。这边官方题解方法三，数学法。
```
	public int superEggDrop(int K, int N) {
        // m 最多不会超过 N 次（线性扫描）
        int[][] dp = new int[K + 1][N + 1];
        // base case:
        // dp[0][..] = 0
        // dp[..][0] = 0
        // Java 默认初始化数组都为 0
        int m = 0;
        while (dp[K][m] < N) {
            m++;
            for (int k = 1; k <= K; k++)
                dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1;
        }
        return m;
    }
```

