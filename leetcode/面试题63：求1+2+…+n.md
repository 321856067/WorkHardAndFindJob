## 面试题63：求1+2+…+n
**题目：求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。**

**思路：题目要求不能使用者写关键字，那么显然，公式计算的方法不能用了，常用的递归方法也不能用了（因为要用if判断终止条件），暴力循环也不能用了。不过我们可以对这些条件做文章。**

**方法1，利用&&短路特性来替代if的判断，实现递归。**
```
	public int sumNums(int n) {
        int sum = n;
//        这边当 n<=0之后，后面的 ((sum += sumNums(n - 1)) > 0) 不会执行，这就是短路。达到了if的效果。
        boolean s = (n > 0) && ((sum += sumNums(n - 1)) > 0);
        return sum;
    }
```
**时间击败60.5。**

**方法2,不能用乘除法这样我们就不能用公式了？天真。 等差数列解法 n * (n + 1) /2 -> (n ^2 + n) /2, 将 /2 变成位移不就好了。狗头**
```
public int sumNums(int n) {
		return (n+(int)Math.pow(n,2))>>1;
    }
```
**击败双100.**

**以及"这么写会不会被打"的的方法。**
```
	public int sumNums(int n) {
		return IntStream.rangeClosed(1, n).sum();
    }
```

**还有"这是什么神仙解法？"的方法。**

**因为题目设定n<10000，n可能的最大拆分项为2^13=8192，问题是如何确定2的0-13次幂什么时候需要。比如11=8+2+1，只需要2的0、1、3次幂，所以要保证我们在加上其他次幂时无效。举例：(n>>>3)&1可以通过结果判断n的二进制第3位是0或者1，(0-((n>>>3)&1))可以决定此次相加是否有效，如果有效(0-((n>>>3)&1))=-1，然后(n+1)&(-1)=(n+1)还是其本身,再通过左移3位实现×8的效果，如果无效(0-((n>>>3)&1))=0，(n+1)&0=0,此时在左移3位，结果还是0.
**
```
public int sumNums(int n) {
	return
        ((((n+1)&(0-((n>>>13)&1)))<<13)+
        (((n+1)&(0-((n>>>12)&1)))<<12)+
        (((n+1)&(0-((n>>>11)&1)))<<11)+
        (((n+1)&(0-((n>>>10)&1)))<<10)+
        (((n+1)&(0-((n>>>9)&1)))<<9)+
        (((n+1)&(0-((n>>>8)&1)))<<8)+
        (((n+1)&(0-((n>>>7)&1)))<<7)+
        (((n+1)&(0-((n>>>6)&1)))<<6)+
        (((n+1)&(0-((n>>>5)&1)))<<5)+
        (((n+1)&(0-((n>>>4)&1)))<<4)+
        (((n+1)&(0-((n>>>3)&1)))<<3)+
        (((n+1)&(0-((n>>>2)&1)))<<2)+
        (((n+1)&(0-((n>>>1)&1)))<<1)+
        ((n+1)&(0-(n&1))))>>>1;
    }
```