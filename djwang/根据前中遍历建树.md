```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
 
 //时间复杂度为O(n^2),空间复杂度为O(n)
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        //根据遍历的性质使用递归分别建立左右子树
        return build(preorder,0,preorder.length-1,inorder,0,inorder.length-1);
    }

    public TreeNode build(int[] preorder,int prefirst,int prelast,int[] inorder,int infirst,int inlast){
        if(prefirst>prelast) return null;
        TreeNode node=new TreeNode(preorder[prefirst]);
        if(prefirst==prelast) return node;
        int i=infirst;
        while(inorder[i++]!=preorder[prefirst]);
        node.left=build(preorder,prefirst+1,prefirst+i-1-infirst,inorder,infirst,i-1);
        node.right=build(preorder,prefirst+i-infirst,prelast,inorder,i,inlast);
        return node;
    }
}
```